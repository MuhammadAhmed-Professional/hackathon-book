"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[318],{3237:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module2/urdf-vs-sdf","title":"URDF vs SDF: Choosing the Right Format","description":"Understand when to use URDF vs SDF for robot descriptions, with conversion workflows","source":"@site/docs/module2/urdf-vs-sdf.md","sourceDirName":"module2","slug":"/module2/urdf-vs-sdf","permalink":"/hackathon-book/docs/module2/urdf-vs-sdf","draft":false,"unlisted":false,"editUrl":"https://github.com/MuhammadAhmed-Professional/hackathon-book/tree/master/frontend/docs/module2/urdf-vs-sdf.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"urdf-vs-sdf","title":"URDF vs SDF: Choosing the Right Format","sidebar_position":2,"description":"Understand when to use URDF vs SDF for robot descriptions, with conversion workflows"},"sidebar":"tutorialSidebar","previous":{"title":"Gazebo Simulation Fundamentals","permalink":"/hackathon-book/docs/module2/gazebo-simulation"},"next":{"title":"Physics Simulation Deep Dive","permalink":"/hackathon-book/docs/module2/physics-simulation"}}');var r=i(4848),o=i(8453);const t={id:"urdf-vs-sdf",title:"URDF vs SDF: Choosing the Right Format",sidebar_position:2,description:"Understand when to use URDF vs SDF for robot descriptions, with conversion workflows"},l="URDF vs SDF: Choosing the Right Format",d={},a=[{value:"The Origins: Why Two Formats?",id:"the-origins-why-two-formats",level:2},{value:"URDF: Strengths and Limitations",id:"urdf-strengths-and-limitations",level:2},{value:"Strengths",id:"strengths",level:3},{value:"Limitations",id:"limitations",level:3},{value:"SDF: Strengths and Limitations",id:"sdf-strengths-and-limitations",level:2},{value:"Strengths",id:"strengths-1",level:3},{value:"Limitations",id:"limitations-1",level:3},{value:"When to Use URDF vs SDF",id:"when-to-use-urdf-vs-sdf",level:2},{value:"Converting URDF to SDF",id:"converting-urdf-to-sdf",level:2},{value:"Converting SDF to URDF (Limited)",id:"converting-sdf-to-urdf-limited",level:2},{value:"Hybrid Workflow: Best of Both Worlds",id:"hybrid-workflow-best-of-both-worlds",level:2},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"urdf-vs-sdf-choosing-the-right-format",children:"URDF vs SDF: Choosing the Right Format"})}),"\n",(0,r.jsxs)(e.p,{children:["As you dive deeper into robot simulation, you'll encounter two primary robot description formats: ",(0,r.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"})," and ",(0,r.jsx)(e.strong,{children:"SDF (Simulation Description Format)"}),". While both describe robot geometry and kinematics, they serve different purposes and have distinct capabilities. Understanding when to use each\u2014and how to convert between them\u2014is essential for effective robotics development."]}),"\n",(0,r.jsx)(e.p,{children:"In this chapter, you'll learn the technical differences between URDF and SDF, discover their respective strengths and limitations, and master the conversion workflows that connect ROS 2 ecosystems with Gazebo simulations."}),"\n",(0,r.jsx)(e.h2,{id:"the-origins-why-two-formats",children:"The Origins: Why Two Formats?"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"URDF"})," was created as part of ROS 1 (circa 2009) to standardize robot descriptions for visualization (RViz) and motion planning (MoveIt). Its design prioritizes:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Kinematic tree representation"}),"\n",(0,r.jsx)(e.li,{children:"ROS tool compatibility"}),"\n",(0,r.jsx)(e.li,{children:"Human-readable XML"}),"\n",(0,r.jsx)(e.li,{children:"TF (Transform) tree generation"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"SDF"})," emerged from Gazebo's need for more expressive simulation capabilities (circa 2012). It extends beyond URDF to support:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Complete world descriptions (multiple robots, lights, physics)"}),"\n",(0,r.jsx)(e.li,{children:"Advanced sensor models (GPU LIDAR, depth cameras)"}),"\n",(0,r.jsx)(e.li,{children:"Plugin architecture for custom behaviors"}),"\n",(0,r.jsx)(e.li,{children:"Multiple physics engines with detailed configurations"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key insight"}),": URDF is a ",(0,r.jsx)(e.strong,{children:"robot description format"}),", while SDF is a ",(0,r.jsx)(e.strong,{children:"world description format"}),". Think of URDF as a blueprint for one robot, and SDF as a blueprint for an entire simulated environment."]}),"\n",(0,r.jsx)(e.h2,{id:"urdf-strengths-and-limitations",children:"URDF: Strengths and Limitations"}),"\n",(0,r.jsx)(e.h3,{id:"strengths",children:"Strengths"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. ROS Ecosystem Integration"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- URDF seamlessly integrates with ROS 2 tools --\x3e\n<robot name="my_robot">\n  <link name="base_link">\n    <visual>\n      <geometry><box size="0.5 0.3 0.2"/></geometry>\n    </visual>\n  </link>\n</robot>\n'})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"robot_state_publisher"}),": Automatically publishes TF transforms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"joint_state_publisher"}),": GUI for manual joint control"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"MoveIt 2"}),": Motion planning requires URDF input"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"RViz2"}),": Native URDF visualization"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"2. Simplicity and Readability"}),"\nURDF files are concise for basic robots. A wheeled platform can be defined in < 100 lines of XML."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"3. Xacro Support"}),"\nXacro (XML Macros) adds programmability:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<xacro:property name="wheel_radius" value="0.1"/>\n<xacro:macro name="wheel" params="prefix reflect">\n  <link name="${prefix}_wheel">\n    <visual>\n      <geometry>\n        <cylinder radius="${wheel_radius}" length="0.05"/>\n      </geometry>\n    </visual>\n  </link>\n</xacro:macro>\n\n<xacro:wheel prefix="left" reflect="1"/>\n<xacro:wheel prefix="right" reflect="-1"/>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"1. No Multi-Robot Support"}),"\nURDF describes ",(0,r.jsx)(e.strong,{children:"one robot at a time"}),". You cannot define multiple robots or environmental objects (tables, walls) in a single URDF file."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Limited Physics Configuration"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- URDF has minimal physics control --\x3e\n<joint name="elbow" type="revolute">\n  <dynamics damping="0.5" friction="0.1"/>\n  \x3c!-- That\'s it - no solver config, contact parameters, etc. --\x3e\n</joint>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"3. No Sensor Plugins"}),"\nURDF has no native plugin system. To add a camera, you must:"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Define the sensor link in URDF"}),"\n",(0,r.jsxs)(e.li,{children:["Add Gazebo-specific tags (wrapped in ",(0,r.jsx)(e.code,{children:"<gazebo>"})," tags)"]}),"\n",(0,r.jsx)(e.li,{children:"Hope the Gazebo parser recognizes your plugin"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"4. No World Elements"}),"\nURDF cannot specify:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Lighting (sun, spotlights, ambient)"}),"\n",(0,r.jsx)(e.li,{children:"Ground planes"}),"\n",(0,r.jsx)(e.li,{children:"Gravity direction/magnitude"}),"\n",(0,r.jsx)(e.li,{children:"Atmospheric effects"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"sdf-strengths-and-limitations",children:"SDF: Strengths and Limitations"}),"\n",(0,r.jsx)(e.h3,{id:"strengths-1",children:"Strengths"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. Complete World Descriptions"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sdf version="1.9">\n  <world name="humanoid_lab">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="dart">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/ground_plane</uri>\n    </include>\n\n    \x3c!-- Multiple robots --\x3e\n    <model name="robot1">\n      <pose>0 0 0 0 0 0</pose>\n      \x3c!-- Robot definition --\x3e\n    </model>\n\n    <model name="robot2">\n      <pose>5 0 0 0 0 0</pose>\n      \x3c!-- Another robot --\x3e\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Advanced Sensor Modeling"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="rgbd_camera" type="rgbd_camera">\n  <update_rate>30</update_rate>\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>10.0</far>\n    </clip>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>\n    </noise>\n    <distortion>\n      <k1>-0.25</k1>  \x3c!-- Barrel distortion --\x3e\n      <k2>0.12</k2>\n      <k3>-0.03</k3>\n      <p1>-0.0005</p1>  \x3c!-- Tangential distortion --\x3e\n      <p2>0.0002</p2>\n      <center>0.5 0.5</center>\n    </distortion>\n  </camera>\n\n  \x3c!-- Native plugin support --\x3e\n  <plugin filename="gz-sim-sensors-system" name="gz::sim::systems::Sensors">\n    <render_engine>ogre2</render_engine>\n  </plugin>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"3. Detailed Physics Configuration"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="dart">\n  <dart>\n    <solver>\n      <solver_type>dantzig</solver_type>  \x3c!-- LCP solver choice --\x3e\n      <solver_iterations>50</solver_iterations>\n    </solver>\n\n    <collision_detector>bullet</collision_detector>\n\n    \x3c!-- Contact surface properties --\x3e\n    <contact>\n      <friction>\n        <ode>\n          <mu>1.0</mu>  \x3c!-- Coefficient of friction --\x3e\n          <mu2>0.8</mu2>\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.3</restitution_coefficient>\n        <threshold>0.01</threshold>\n      </bounce>\n    </contact>\n  </dart>\n</physics>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"4. Plugin System"}),"\nSDF plugins extend functionality without recompiling Gazebo:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Model plugins: Custom robot behaviors"}),"\n",(0,r.jsx)(e.li,{children:"Sensor plugins: Custom sensor processing"}),"\n",(0,r.jsx)(e.li,{children:"World plugins: Environmental effects (wind, water currents)"}),"\n",(0,r.jsx)(e.li,{children:"System plugins: Core simulation modifications"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"limitations-1",children:"Limitations"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"1. Complexity"}),"\nSDF files can grow to thousands of lines for realistic worlds. A humanoid robot in a furnished room might be 5,000+ lines."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Limited ROS Tool Support"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"MoveIt 2 requires URDF (no native SDF support)"}),"\n",(0,r.jsx)(e.li,{children:"Most ROS visualization tools expect URDF"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"robot_state_publisher"})," only reads URDF"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"3. Version Fragmentation"}),"\nSDF has multiple versions (1.4, 1.6, 1.7, 1.9), with breaking changes between them. URDF is more stable."]}),"\n",(0,r.jsx)(e.h2,{id:"when-to-use-urdf-vs-sdf",children:"When to Use URDF vs SDF"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Use Case"}),(0,r.jsx)(e.th,{children:"Recommended Format"}),(0,r.jsx)(e.th,{children:"Rationale"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Motion Planning (MoveIt 2)"})}),(0,r.jsx)(e.td,{children:"URDF"}),(0,r.jsx)(e.td,{children:"MoveIt requires URDF kinematic descriptions"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Gazebo Simulation"})}),(0,r.jsx)(e.td,{children:"SDF"}),(0,r.jsx)(e.td,{children:"Native format, full feature support"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"RViz Visualization"})}),(0,r.jsx)(e.td,{children:"URDF"}),(0,r.jsx)(e.td,{children:"Direct compatibility with robot_state_publisher"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Multi-Robot Simulation"})}),(0,r.jsx)(e.td,{children:"SDF"}),(0,r.jsx)(e.td,{children:"URDF cannot describe multiple robots"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Custom Sensors (LIDAR, Depth Camera)"})}),(0,r.jsx)(e.td,{children:"SDF"}),(0,r.jsx)(e.td,{children:"Advanced sensor models and plugins"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"ROS Package Distribution"})}),(0,r.jsx)(e.td,{children:"URDF"}),(0,r.jsx)(e.td,{children:"Standard for sharing robot descriptions"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Physics Research"})}),(0,r.jsx)(e.td,{children:"SDF"}),(0,r.jsx)(e.td,{children:"Detailed physics engine configuration"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Quick Prototyping"})}),(0,r.jsx)(e.td,{children:"URDF"}),(0,r.jsx)(e.td,{children:"Simpler syntax, faster iteration"})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Practical recommendation"}),": Start with URDF for robot modeling, then convert to SDF when you need advanced Gazebo features."]}),"\n",(0,r.jsx)(e.h2,{id:"converting-urdf-to-sdf",children:"Converting URDF to SDF"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo provides built-in conversion tools:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Method 1: Using gz command-line tool\ngz sdf -p my_robot.urdf > my_robot.sdf\n\n# Method 2: Programmatic conversion in launch files\nfrom launch_ros.actions import Node\n\nNode(\n    package='ros_gz_bridge',\n    executable='parameter_bridge',\n    arguments=['--urdf-file', 'my_robot.urdf', '--output-sdf', 'my_robot.sdf']\n)\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Conversion behavior"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u2705 Links and joints are preserved"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Visual and collision geometry converted"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Inertial properties transferred"}),"\n",(0,r.jsxs)(e.li,{children:["\u26a0\ufe0f Gazebo-specific ",(0,r.jsx)(e.code,{children:"<gazebo>"})," tags extracted to SDF plugins"]}),"\n",(0,r.jsxs)(e.li,{children:["\u26a0\ufe0f Xacro macros must be pre-processed (",(0,r.jsx)(e.code,{children:"xacro my_robot.urdf.xacro > my_robot.urdf"}),")"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example conversion"}),":"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Input URDF"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_arm">\n  <link name="base_link">\n    <visual>\n      <geometry><box size="0.2 0.2 0.1"/></geometry>\n    </visual>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.05"/>\n    </inertial>\n  </link>\n\n  <link name="arm_link">\n    <visual>\n      <geometry><cylinder radius="0.03" length="0.5"/></geometry>\n    </visual>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="shoulder" type="revolute">\n    <parent link="base_link"/>\n    <child link="arm_link"/>\n    <origin xyz="0 0 0.05"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="2.0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Output SDF"})," (simplified):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sdf version="1.9">\n  <model name="simple_arm">\n    <link name="base_link">\n      <pose>0 0 0 0 0 0</pose>\n      <visual name="visual">\n        <geometry><box><size>0.2 0.2 0.1</size></box></geometry>\n      </visual>\n      <inertial>\n        <mass>5.0</mass>\n        <inertia>\n          <ixx>0.1</ixx><ixy>0</ixy><ixz>0</ixz>\n          <iyy>0.1</iyy><iyz>0</iyz><izz>0.05</izz>\n        </inertia>\n      </inertial>\n    </link>\n\n    <link name="arm_link">\n      <pose relative_to="shoulder">0 0 0 0 0 0</pose>\n      <visual name="visual">\n        <geometry><cylinder><radius>0.03</radius><length>0.5</length></cylinder></geometry>\n      </visual>\n      <inertial>\n        <mass>2.0</mass>\n        <inertia>\n          <ixx>0.04</ixx><ixy>0</ixy><ixz>0</ixz>\n          <iyy>0.04</iyy><iyz>0</iyz><izz>0.001</izz>\n        </inertia>\n      </inertial>\n    </link>\n\n    <joint name="shoulder" type="revolute">\n      <parent>base_link</parent>\n      <child>arm_link</child>\n      <pose relative_to="base_link">0 0 0.05 0 0 0</pose>\n      <axis>\n        <xyz>0 1 0</xyz>\n        <limit>\n          <lower>-1.57</lower>\n          <upper>1.57</upper>\n          <effort>50</effort>\n          <velocity>2.0</velocity>\n        </limit>\n      </axis>\n    </joint>\n  </model>\n</sdf>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key differences"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["SDF wraps everything in ",(0,r.jsx)(e.code,{children:"<model>"})," tag"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"<pose>"})," replaces URDF's ",(0,r.jsx)(e.code,{children:"<origin>"})]}),"\n",(0,r.jsx)(e.li,{children:"More verbose inertia syntax"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"relative_to"})," attribute for frame relationships"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"converting-sdf-to-urdf-limited",children:"Converting SDF to URDF (Limited)"}),"\n",(0,r.jsxs)(e.p,{children:["SDF \u2192 URDF conversion is ",(0,r.jsx)(e.strong,{children:"not officially supported"})," because SDF contains features that cannot be represented in URDF (world elements, plugins, advanced sensors). However, you can extract a single model:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport xml.etree.ElementTree as ET\n\ndef sdf_model_to_urdf(sdf_file, model_name, output_urdf):\n    \"\"\"Extract single model from SDF and convert to URDF.\"\"\"\n    tree = ET.parse(sdf_file)\n    root = tree.getroot()\n\n    # Find the model element\n    model = root.find(f\".//model[@name='{model_name}']\")\n    if model is None:\n        raise ValueError(f\"Model '{model_name}' not found in SDF\")\n\n    # Create URDF root\n    urdf_root = ET.Element('robot', name=model_name)\n\n    # Convert links\n    for sdf_link in model.findall('link'):\n        urdf_link = ET.SubElement(urdf_root, 'link', name=sdf_link.get('name'))\n\n        # Copy visual elements\n        for visual in sdf_link.findall('visual'):\n            urdf_visual = ET.SubElement(urdf_link, 'visual')\n            # Copy geometry, etc.\n\n        # Copy collision elements\n        # Copy inertial elements\n        # ... (implementation details omitted)\n\n    # Convert joints\n    for sdf_joint in model.findall('joint'):\n        urdf_joint = ET.SubElement(urdf_root, 'joint',\n                                    name=sdf_joint.get('name'),\n                                    type=sdf_joint.get('type'))\n        # ... (convert joint properties)\n\n    # Write URDF file\n    tree = ET.ElementTree(urdf_root)\n    tree.write(output_urdf, encoding='utf-8', xml_declaration=True)\n\n# Usage\nsdf_model_to_urdf('humanoid_world.sdf', 'my_humanoid', 'my_humanoid.urdf')\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Warning"}),": This conversion loses SDF-specific features (plugins, sensors, physics config). Use only when you need a URDF for ROS tools."]}),"\n",(0,r.jsx)(e.h2,{id:"hybrid-workflow-best-of-both-worlds",children:"Hybrid Workflow: Best of Both Worlds"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Recommended approach"})," for complex projects:"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Author robot in URDF + Xacro"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"my_robot_description/\n\u251c\u2500\u2500 urdf/\n\u2502   \u251c\u2500\u2500 my_robot.urdf.xacro  # Main robot file\n\u2502   \u251c\u2500\u2500 materials.xacro       # Colors and textures\n\u2502   \u251c\u2500\u2500 sensors.xacro         # Sensor definitions\n\u2502   \u2514\u2500\u2500 gazebo.xacro          # Gazebo-specific tags\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Generate URDF from Xacro"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"xacro my_robot.urdf.xacro > my_robot.urdf\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Convert to SDF for Gazebo"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"gz sdf -p my_robot.urdf > ../sdf/my_robot.sdf\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Enhance SDF with advanced features"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add to generated SDF --\x3e\n<physics type="dart">\n  <max_step_size>0.0001</max_step_size>\n</physics>\n\n<plugin filename="my_custom_plugin" name="MyPlugin">\n  <parameter>value</parameter>\n</plugin>\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use URDF for ROS tools"}),", ",(0,r.jsx)(e.strong,{children:"SDF for Gazebo"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Motion planning (MoveIt): Use URDF"}),"\n",(0,r.jsx)(e.li,{children:"Simulation (Gazebo): Use SDF"}),"\n",(0,r.jsx)(e.li,{children:"Visualization (RViz): Use URDF"}),"\n",(0,r.jsx)(e.li,{children:"Multi-robot scenarios: Use SDF world file"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Challenge"}),": Convert your humanoid arm from Module 1 to SDF and enhance it:"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Convert URDF to SDF using ",(0,r.jsx)(e.code,{children:"gz sdf"})]}),"\n",(0,r.jsxs)(e.li,{children:["Add a realistic world with:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Ground plane"}),"\n",(0,r.jsx)(e.li,{children:"Directional lighting (sun)"}),"\n",(0,r.jsx)(e.li,{children:"Physics engine (DART with 0.001s timestep)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Add a camera sensor to the end effector"}),"\n",(0,r.jsx)(e.li,{children:"Add joint position controller plugins"}),"\n",(0,r.jsx)(e.li,{children:"Launch in Gazebo and verify camera feed in RViz"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Validation checklist"}),":"]}),"\n",(0,r.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","SDF parses without errors (",(0,r.jsx)(e.code,{children:"gz sdf --check my_robot.sdf"}),")"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Robot spawns in Gazebo"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Camera publishes to ",(0,r.jsx)(e.code,{children:"/camera"})," topic"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Joint controllers respond to commands"]}),"\n",(0,r.jsxs)(e.li,{className:"task-list-item",children:[(0,r.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Physics runs at \u2265 1.0x real-time"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"URDF"}),": Robot descriptions for ROS ecosystem (MoveIt, RViz, TF)\n\u2705 ",(0,r.jsx)(e.strong,{children:"SDF"}),": World descriptions for Gazebo simulation (physics, sensors, plugins)\n\u2705 ",(0,r.jsx)(e.strong,{children:"Conversion"}),": URDF \u2192 SDF (supported), SDF \u2192 URDF (limited, model extraction only)\n\u2705 ",(0,r.jsx)(e.strong,{children:"Workflow"}),": Author in URDF, convert to SDF, enhance with simulation features\n\u2705 ",(0,r.jsx)(e.strong,{children:"Tool compatibility"}),": URDF for ROS tools, SDF for Gazebo simulation\n\u2705 ",(0,r.jsx)(e.strong,{children:"Complexity trade-off"}),": URDF is simpler, SDF is more powerful"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Next steps"}),": Dive deeper into physics simulation parameters to understand how to tune contact forces, friction, and solver settings for stable humanoid simulation."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Related chapters"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/hackathon-book/docs/module1/urdf-for-humanoids",children:"URDF for Humanoids"})," - Robot modeling foundation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/hackathon-book/docs/module2/gazebo-simulation",children:"Gazebo Simulation"})," - Using SDF in practice"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/hackathon-book/docs/module2/physics-simulation",children:"Physics Simulation"})," - Next chapter: tuning physics engines"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>l});var s=i(6540);const r={},o=s.createContext(r);function t(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);