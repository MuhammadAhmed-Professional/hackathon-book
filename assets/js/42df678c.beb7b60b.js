"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[4281],{943:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module2/physics-simulation","title":"Physics Simulation Deep Dive","description":"Master rigid body dynamics, collision detection, contact forces, and physics tuning for humanoid robots","source":"@site/docs/module2/physics-simulation.md","sourceDirName":"module2","slug":"/module2/physics-simulation","permalink":"/hackathon-book/docs/module2/physics-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/MuhammadAhmed-Professional/hackathon-book/tree/master/frontend/docs/module2/physics-simulation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"physics-simulation","title":"Physics Simulation Deep Dive","sidebar_position":3,"description":"Master rigid body dynamics, collision detection, contact forces, and physics tuning for humanoid robots"},"sidebar":"tutorialSidebar","previous":{"title":"URDF vs SDF: Choosing the Right Format","permalink":"/hackathon-book/docs/module2/urdf-vs-sdf"},"next":{"title":"Unity for High-Fidelity Robot Rendering","permalink":"/hackathon-book/docs/module2/unity-rendering"}}');var t=i(4848),r=i(8453);const o={id:"physics-simulation",title:"Physics Simulation Deep Dive",sidebar_position:3,description:"Master rigid body dynamics, collision detection, contact forces, and physics tuning for humanoid robots"},l="Physics Simulation Deep Dive",c={},a=[{value:"Rigid Body Dynamics: The Foundation",id:"rigid-body-dynamics-the-foundation",level:2},{value:"Newton-Euler Equations",id:"newton-euler-equations",level:3},{value:"State Vector",id:"state-vector",level:3},{value:"Integration: From Forces to Motion",id:"integration-from-forces-to-motion",level:3},{value:"Collision Detection: Finding Contacts",id:"collision-detection-finding-contacts",level:2},{value:"Broad Phase: Spatial Partitioning",id:"broad-phase-spatial-partitioning",level:3},{value:"Narrow Phase: Precise Contact Points",id:"narrow-phase-precise-contact-points",level:3},{value:"Contact Forces: Making Objects Interact",id:"contact-forces-making-objects-interact",level:2},{value:"Normal Force: Preventing Penetration",id:"normal-force-preventing-penetration",level:3},{value:"Friction: Tangential Forces",id:"friction-tangential-forces",level:3},{value:"Restitution: Bounciness",id:"restitution-bounciness",level:3},{value:"Constraint Solvers: Joint Dynamics",id:"constraint-solvers-joint-dynamics",level:2},{value:"Lagrange Multipliers",id:"lagrange-multipliers",level:3},{value:"Solver Types",id:"solver-types",level:3},{value:"Timestep and Real-Time Factor",id:"timestep-and-real-time-factor",level:2},{value:"Choosing Timestep",id:"choosing-timestep",level:3},{value:"Real-Time Factor (RTF)",id:"real-time-factor-rtf",level:3},{value:"Tuning Physics for Stable Humanoid Simulation",id:"tuning-physics-for-stable-humanoid-simulation",level:2},{value:"Problem 1: Jittering Feet",id:"problem-1-jittering-feet",level:3},{value:"Problem 2: Exploding Robot",id:"problem-2-exploding-robot",level:3},{value:"Problem 3: Foot Slip During Walking",id:"problem-3-foot-slip-during-walking",level:3},{value:"Problem 4: Slow Simulation (RTF &lt; 0.5)",id:"problem-4-slow-simulation-rtf--05",level:3},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"physics-simulation-deep-dive",children:"Physics Simulation Deep Dive"})}),"\n",(0,t.jsx)(n.p,{children:"Physics simulation is the heart of any robotics simulator. It transforms static 3D models into dynamic systems that respond to gravity, collisions, and actuator forces. For humanoid robots\u2014with their high degree-of-freedom articulated bodies, complex contact dynamics, and balance requirements\u2014understanding physics simulation is not optional; it's essential."}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, you'll learn the fundamentals of rigid body dynamics, explore collision detection algorithms, master contact force modeling, and discover how to tune physics parameters for stable, real-time simulation of humanoid robots."}),"\n",(0,t.jsx)(n.h2,{id:"rigid-body-dynamics-the-foundation",children:"Rigid Body Dynamics: The Foundation"}),"\n",(0,t.jsxs)(n.p,{children:["Every link in your robot is a ",(0,t.jsx)(n.strong,{children:"rigid body"}),"\u2014an object whose shape doesn't deform under forces. Rigid body dynamics governs how these bodies move and interact."]}),"\n",(0,t.jsx)(n.h3,{id:"newton-euler-equations",children:"Newton-Euler Equations"}),"\n",(0,t.jsx)(n.p,{children:"The motion of each rigid body is determined by:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Translation"})," (linear motion):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"F = m * a\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"F"}),": Total force vector (N)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m"}),": Mass (kg)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a"}),": Linear acceleration (m/s\xb2)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rotation"})," (angular motion):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u03c4 = I * \u03b1 + \u03c9 \xd7 (I * \u03c9)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"\u03c4"}),": Total torque vector (Nm)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"I"}),": Inertia tensor (3x3 matrix, kg\xb7m\xb2)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"\u03b1"}),": Angular acceleration (rad/s\xb2)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"\u03c9"}),": Angular velocity (rad/s)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"\xd7"}),": Cross product"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The second term"})," ",(0,t.jsx)(n.code,{children:"\u03c9 \xd7 (I * \u03c9)"})," represents gyroscopic effects\u2014crucial for spinning objects like flywheels or rotating joints."]}),"\n",(0,t.jsx)(n.h3,{id:"state-vector",children:"State Vector"}),"\n",(0,t.jsx)(n.p,{children:"At each timestep, the simulator tracks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"state = {\n    'position': [x, y, z],           # m\n    'orientation': [qw, qx, qy, qz], # quaternion (avoids gimbal lock)\n    'linear_velocity': [vx, vy, vz], # m/s\n    'angular_velocity': [wx, wy, wz] # rad/s\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why quaternions?"})," Euler angles (roll, pitch, yaw) suffer from gimbal lock at \xb190\xb0 pitch. Quaternions avoid this and enable smooth interpolation."]}),"\n",(0,t.jsx)(n.h3,{id:"integration-from-forces-to-motion",children:"Integration: From Forces to Motion"}),"\n",(0,t.jsxs)(n.p,{children:["Physics engines use ",(0,t.jsx)(n.strong,{children:"numerical integration"})," to update the state over time:"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explicit Euler"})," (simplest, least stable):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def step(state, forces, dt):\n    """One timestep of explicit Euler integration."""\n    acceleration = forces / mass\n    state.velocity += acceleration * dt\n    state.position += state.velocity * dt\n    return state\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Semi-Implicit Euler"})," (better stability):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def step(state, forces, dt):\n    """Semi-implicit Euler (update velocity first)."""\n    state.velocity += (forces / mass) * dt  # Update velocity first\n    state.position += state.velocity * dt    # Then update position\n    return state\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Runge-Kutta 4th Order (RK4)"})," (high accuracy, computationally expensive):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def step(state, forces, dt):\n    """4th-order Runge-Kutta integration."""\n    k1 = dt * derivative(state, forces)\n    k2 = dt * derivative(state + 0.5*k1, forces)\n    k3 = dt * derivative(state + 0.5*k2, forces)\n    k4 = dt * derivative(state + k3, forces)\n\n    state += (k1 + 2*k2 + 2*k3 + k4) / 6\n    return state\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gazebo default"}),": Semi-implicit Euler (good balance of speed and stability)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For humanoid robots"}),": Use small timesteps (0.0001-0.001s) with semi-implicit Euler. RK4 is overkill for most scenarios."]}),"\n",(0,t.jsx)(n.h2,{id:"collision-detection-finding-contacts",children:"Collision Detection: Finding Contacts"}),"\n",(0,t.jsx)(n.p,{children:"Before computing contact forces, the simulator must detect which objects are colliding."}),"\n",(0,t.jsx)(n.h3,{id:"broad-phase-spatial-partitioning",children:"Broad Phase: Spatial Partitioning"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": Quickly eliminate pairs of objects that are far apart."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Axis-Aligned Bounding Box (AABB)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class AABB:\n    def __init__(self, min_point, max_point):\n        self.min = min_point  # [x_min, y_min, z_min]\n        self.max = max_point  # [x_max, y_max, z_max]\n\n    def intersects(self, other):\n        """Check if two AABBs overlap."""\n        return (self.min[0] <= other.max[0] and self.max[0] >= other.min[0] and\n                self.min[1] <= other.max[1] and self.max[1] >= other.min[1] and\n                self.min[2] <= other.max[2] and self.max[2] >= other.min[2])\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Algorithms"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sweep and Prune"}),": Sort AABBs along one axis, detect overlaps"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Spatial Hashing"}),": Divide space into grid cells, check neighbors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bounding Volume Hierarchy (BVH)"}),": Tree structure for fast queries"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gazebo uses"}),": BVH for complex meshes, spatial hashing for simple scenes"]}),"\n",(0,t.jsx)(n.h3,{id:"narrow-phase-precise-contact-points",children:"Narrow Phase: Precise Contact Points"}),"\n",(0,t.jsx)(n.p,{children:"Once a potential collision is found, compute exact contact geometry:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Primitive Shapes"})," (sphere, box, cylinder):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def sphere_sphere_collision(sphere1, sphere2):\n    \"\"\"Detect collision between two spheres.\"\"\"\n    distance = np.linalg.norm(sphere1.position - sphere2.position)\n    combined_radius = sphere1.radius + sphere2.radius\n\n    if distance < combined_radius:\n        penetration_depth = combined_radius - distance\n        contact_normal = (sphere2.position - sphere1.position) / distance\n        contact_point = sphere1.position + contact_normal * sphere1.radius\n\n        return {\n            'penetration': penetration_depth,\n            'normal': contact_normal,\n            'point': contact_point\n        }\n    return None\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Convex Meshes"})," (arbitrary shapes):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GJK (Gilbert-Johnson-Keerthi)"}),": Iterative algorithm to find closest points"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"EPA (Expanding Polytope Algorithm)"}),": Extends GJK to compute penetration depth"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Concave Meshes"})," (e.g., terrain):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decomposition"}),": Break into convex pieces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Heightmap"}),": Special case for terrains (fast ray-mesh intersection)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Performance tip"}),": Use primitive shapes (spheres, cylinders) for collision geometry, even if visual geometry is a complex mesh. A humanoid foot can be approximated as 3-4 spheres for fast contact detection."]}),"\n",(0,t.jsx)(n.h2,{id:"contact-forces-making-objects-interact",children:"Contact Forces: Making Objects Interact"}),"\n",(0,t.jsx)(n.p,{children:"When two objects collide, the simulator must compute contact forces to prevent interpenetration."}),"\n",(0,t.jsx)(n.h3,{id:"normal-force-preventing-penetration",children:"Normal Force: Preventing Penetration"}),"\n",(0,t.jsx)(n.p,{children:"The normal force pushes objects apart:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"F_normal = k_p * penetration_depth + k_d * relative_velocity_normal\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"k_p"}),": Spring stiffness (N/m)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"k_d"}),": Damping coefficient (N\xb7s/m)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"In Gazebo SDF"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<contact>\n  <ode>\n    <kp>1000000.0</kp>  \x3c!-- Spring stiffness --\x3e\n    <kd>100.0</kd>      \x3c!-- Damping --\x3e\n    <max_vel>0.01</max_vel>  \x3c!-- Max penetration velocity --\x3e\n    <min_depth>0.001</min_depth>  \x3c!-- Minimum penetration to register --\x3e\n  </ode>\n</contact>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tuning guidelines"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High kp"})," (10\u2076-10\u2078): Stiff contacts (metal on metal)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Medium kp"})," (10\u2074-10\u2076): Soft contacts (rubber, foam)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"kd \u2248 0.1 * kp"}),": Critical damping for stable contacts"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"friction-tangential-forces",children:"Friction: Tangential Forces"}),"\n",(0,t.jsx)(n.p,{children:"Friction prevents sliding:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Coulomb Friction Model"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"F_friction \u2264 \u03bc * F_normal\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"\u03bc"}),": Coefficient of friction (dimensionless)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"F_friction"}),": Tangential force parallel to contact surface"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Typical friction coefficients"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Steel on steel: \u03bc = 0.15-0.25"}),"\n",(0,t.jsx)(n.li,{children:"Rubber on concrete: \u03bc = 0.7-1.0"}),"\n",(0,t.jsx)(n.li,{children:"Teflon on Teflon: \u03bc = 0.04"}),"\n",(0,t.jsx)(n.li,{children:"Ice on ice: \u03bc = 0.02-0.05"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"In Gazebo"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <friction>\n    <ode>\n      <mu>1.0</mu>   \x3c!-- Friction along primary direction --\x3e\n      <mu2>0.8</mu2> \x3c!-- Friction along secondary direction (anisotropic) --\x3e\n      <fdir1>1 0 0</fdir1>  \x3c!-- Primary friction direction --\x3e\n    </ode>\n  </friction>\n</surface>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For humanoid feet"}),": Use \u03bc = 0.8-1.0 to prevent slipping during walking."]}),"\n",(0,t.jsx)(n.h3,{id:"restitution-bounciness",children:"Restitution: Bounciness"}),"\n",(0,t.jsx)(n.p,{children:"Restitution models energy loss in collisions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"coefficient_of_restitution = relative_velocity_after / relative_velocity_before\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"e = 0.0"}),": Perfectly inelastic (no bounce)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"e = 1.0"}),": Perfectly elastic (full bounce)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"e = 0.3"}),": Typical for metal on metal"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"e = 0.9"}),": Bouncy ball"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"In Gazebo"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <bounce>\n    <restitution_coefficient>0.3</restitution_coefficient>\n    <threshold>0.01</threshold>  \x3c!-- Minimum velocity to bounce --\x3e\n  </bounce>\n</surface>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For humanoids"}),": Use e = 0.1-0.3 for stable foot contacts (low bounce)."]}),"\n",(0,t.jsx)(n.h2,{id:"constraint-solvers-joint-dynamics",children:"Constraint Solvers: Joint Dynamics"}),"\n",(0,t.jsxs)(n.p,{children:["Joints (revolute, prismatic, fixed) are implemented as ",(0,t.jsx)(n.strong,{children:"constraints"})," that limit relative motion between links."]}),"\n",(0,t.jsx)(n.h3,{id:"lagrange-multipliers",children:"Lagrange Multipliers"}),"\n",(0,t.jsx)(n.p,{children:"Joints are enforced using constraint forces:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'C(q) = 0  (constraint equation, e.g., "distance between joint origins = 0")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The solver finds forces ",(0,t.jsx)(n.code,{children:"\u03bb"})," that satisfy:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"M * a + J^T * \u03bb = F_external\nJ * a = -\u010a  (time derivative of constraint)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"M"}),": Mass matrix"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"J"}),": Constraint Jacobian matrix"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"\u03bb"}),": Constraint forces (Lagrange multipliers)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"solver-types",children:"Solver Types"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sequential Impulse (SI)"})," (used in Bullet):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def sequential_impulse_solver(contacts, iterations):\n    """Gauss-Seidel style iterative solver."""\n    for _ in range(iterations):\n        for contact in contacts:\n            # Compute impulse to satisfy contact constraint\n            impulse = compute_impulse(contact)\n            apply_impulse(contact.body1, contact.point1, impulse)\n            apply_impulse(contact.body2, contact.point2, -impulse)\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros"}),": Fast, handles large contact counts\n",(0,t.jsx)(n.strong,{children:"Cons"}),": Requires many iterations for stiff systems"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Projected Gauss-Seidel (PGS)"})," (used in ODE):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Similar to SI but with projection step to handle inequality constraints (e.g., friction cone)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dantzig LCP Solver"})," (used in DART):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Solves Linear Complementarity Problem (LCP) exactly"}),"\n",(0,t.jsx)(n.li,{children:"More accurate for stiff contacts (humanoid foot on ground)"}),"\n",(0,t.jsx)(n.li,{children:"Slower than iterative methods"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"In Gazebo"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<physics type=\"dart\">\n  <dart>\n    <solver>\n      <solver_type>dantzig</solver_type>  \x3c!-- or 'pgs' --\x3e\n    </solver>\n  </dart>\n</physics>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation for humanoids"}),": Use DART with Dantzig solver for accurate contact forces during walking."]}),"\n",(0,t.jsx)(n.h2,{id:"timestep-and-real-time-factor",children:"Timestep and Real-Time Factor"}),"\n",(0,t.jsx)(n.h3,{id:"choosing-timestep",children:"Choosing Timestep"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Timestep trade-off"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Small timestep"})," (0.0001s = 10 kHz): Accurate, stable, slow"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Large timestep"})," (0.01s = 100 Hz): Fast, unstable, inaccurate"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rule of thumb"}),": Timestep < 1/10 of fastest oscillation in system."]}),"\n",(0,t.jsx)(n.p,{children:"For a humanoid with:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Joint natural frequency: ~100 Hz (typical for motors)"}),"\n",(0,t.jsx)(n.li,{children:"Contact stiffness: 1 MHz \u2192 natural frequency ~1 kHz"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommended timestep"}),": 0.001s (1 kHz) for balance, 0.0001s (10 kHz) for high-fidelity contact."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"In Gazebo"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<physics type="dart">\n  <max_step_size>0.001</max_step_size>  \x3c!-- 1ms timestep --\x3e\n  <real_time_update_rate>1000</real_time_update_rate>  \x3c!-- 1000 Hz --\x3e\n  <real_time_factor>1.0</real_time_factor>  \x3c!-- Target 1x real-time --\x3e\n</physics>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"real-time-factor-rtf",children:"Real-Time Factor (RTF)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"RTF = simulation_time_elapsed / wall_clock_time_elapsed\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RTF = 1.0"}),": Real-time (1 second simulated = 1 second wall clock)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RTF = 0.5"}),": Half speed (common for complex robots)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RTF = 2.0"}),": Faster than real-time (reinforcement learning training)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Monitor RTF"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"gz topic -e -t /stats\n# Look for <real_time_factor> value\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimization tips"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Simplify collision geometry (spheres > cylinders > meshes)"}),"\n",(0,t.jsx)(n.li,{children:"Reduce joint count (merge fixed joints)"}),"\n",(0,t.jsx)(n.li,{children:"Increase timestep (if stable)"}),"\n",(0,t.jsxs)(n.li,{children:["Disable GUI rendering (",(0,t.jsx)(n.code,{children:"gz sim -s"})," for headless)"]}),"\n",(0,t.jsx)(n.li,{children:"Use multi-threading (DART only)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"tuning-physics-for-stable-humanoid-simulation",children:"Tuning Physics for Stable Humanoid Simulation"}),"\n",(0,t.jsx)(n.h3,{id:"problem-1-jittering-feet",children:"Problem 1: Jittering Feet"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": Humanoid feet vibrate rapidly when standing."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cause"}),": Contact stiffness too high, timestep too large."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<contact>\n  <ode>\n    <kp>500000.0</kp>  \x3c!-- Reduce from 1e6 --\x3e\n    <kd>50.0</kd>      \x3c!-- Increase damping --\x3e\n    <max_vel>0.001</max_vel>  \x3c!-- Limit penetration velocity --\x3e\n  </ode>\n</contact>\n\n<physics>\n  <max_step_size>0.0005</max_step_size>  \x3c!-- Reduce timestep --\x3e\n</physics>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-2-exploding-robot",children:"Problem 2: Exploding Robot"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": Links fly apart explosively at simulation start."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cause"}),": Joint limits violated, constraint solver fails."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Increase solver iterations --\x3e\n<physics type="ode">\n  <ode>\n    <solver>\n      <iters>100</iters>  \x3c!-- Increase from 50 --\x3e\n    </solver>\n  </ode>\n</physics>\n\n\x3c!-- Add joint damping --\x3e\n<joint name="shoulder_pitch">\n  <dynamics>\n    <damping>5.0</damping>  \x3c!-- Nm/(rad/s) --\x3e\n  </dynamics>\n</joint>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"problem-3-foot-slip-during-walking",children:"Problem 3: Foot Slip During Walking"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": Feet slide backward during stance phase."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cause"}),": Friction coefficient too low."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <friction>\n    <ode>\n      <mu>1.2</mu>   \x3c!-- Increase friction --\x3e\n      <mu2>1.0</mu2>\n      <slip1>0.0</slip1>  \x3c!-- Zero slip (perfect friction) --\x3e\n      <slip2>0.0</slip2>\n    </ode>\n  </friction>\n</surface>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-4-slow-simulation-rtf--05",children:"Problem 4: Slow Simulation (RTF < 0.5)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": Simulation can't keep up with real-time."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# 1. Profile physics\ngz topic -e -t /stats\n# Check <sim_time> vs <real_time> ratio\n\n# 2. Simplify collision geometry\n<collision name="foot_collision">\n  <geometry>\n    <sphere radius="0.05"/>  \x3c!-- Use sphere instead of mesh --\x3e\n  </geometry>\n</collision>\n\n# 3. Increase timestep (if stable)\n<max_step_size>0.002</max_step_size>  \x3c!-- 2ms instead of 1ms --\x3e\n\n# 4. Reduce rendering quality\ngz sim --render-engine ogre2 --render-quality low\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Challenge"}),": Create a humanoid balance test:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Spawn your humanoid standing on one leg"}),"\n",(0,t.jsx)(n.li,{children:"Apply lateral forces (10-50 N) to the torso"}),"\n",(0,t.jsxs)(n.li,{children:["Tune physics to achieve:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No foot slip (friction)"}),"\n",(0,t.jsx)(n.li,{children:"Stable standing (damping)"}),"\n",(0,t.jsx)(n.li,{children:"RTF \u2265 0.8 (performance)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Log joint torques and contact forces"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Success criteria"}),":"]}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Robot stands for \u2265 5 seconds without falling"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Foot remains stationary (< 1 cm drift)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Simulation runs at \u2265 0.8x real-time"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No jittering or instability"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Starter code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Wrench\n\nclass ForceApplier(Node):\n    def __init__(self):\n        super().__init__('force_applier')\n        self.publisher = self.create_publisher(Wrench, '/apply_force', 10)\n        self.timer = self.create_timer(2.0, self.apply_lateral_force)\n\n    def apply_lateral_force(self):\n        wrench = Wrench()\n        wrench.force.y = 30.0  # 30 N lateral force\n        self.publisher.publish(wrench)\n        self.get_logger().info('Applied 30 N lateral force')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ForceApplier()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Rigid body dynamics"}),": Newton-Euler equations govern motion\n\u2705 ",(0,t.jsx)(n.strong,{children:"Integration methods"}),": Semi-implicit Euler for speed, RK4 for accuracy\n\u2705 ",(0,t.jsx)(n.strong,{children:"Collision detection"}),": Broad phase (AABBs) + narrow phase (GJK/EPA)\n\u2705 ",(0,t.jsx)(n.strong,{children:"Contact forces"}),": Normal (kp, kd), friction (\u03bc), restitution (e)\n\u2705 ",(0,t.jsx)(n.strong,{children:"Constraint solvers"}),": PGS (fast), Dantzig (accurate)\n\u2705 ",(0,t.jsx)(n.strong,{children:"Timestep rule"}),": < 1/10 of fastest oscillation\n\u2705 ",(0,t.jsx)(n.strong,{children:"Tuning for humanoids"}),": High friction (\u03bc > 0.8), low restitution (e < 0.3), small timestep (1ms)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Next steps"}),": Explore Unity's rendering engine for photorealistic visualization of humanoid robots in human environments, complementing Gazebo's physics-focused simulation."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Related chapters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/hackathon-book/docs/module2/gazebo-simulation",children:"Gazebo Simulation"})," - Applying physics in Gazebo"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/hackathon-book/docs/module2/urdf-vs-sdf",children:"URDF vs SDF"})," - Configuring physics in SDF"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/hackathon-book/docs/module2/unity-rendering",children:"Unity Rendering"})," - Next chapter: high-fidelity visualization"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);