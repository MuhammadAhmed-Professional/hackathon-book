"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[9191],{2310:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module2/gazebo-simulation","title":"Gazebo Simulation Fundamentals","description":"Master Gazebo Classic and Gazebo Sim for realistic robot simulation with physics, sensors, and ROS 2 integration","source":"@site/docs/module2/gazebo-simulation.md","sourceDirName":"module2","slug":"/module2/gazebo-simulation","permalink":"/hackathon-book/docs/module2/gazebo-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/MuhammadAhmed-Professional/hackathon-book/tree/master/frontend/docs/module2/gazebo-simulation.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"gazebo-simulation","title":"Gazebo Simulation Fundamentals","sidebar_position":1,"description":"Master Gazebo Classic and Gazebo Sim for realistic robot simulation with physics, sensors, and ROS 2 integration"},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/hackathon-book/docs/module2/"},"next":{"title":"URDF vs SDF: Choosing the Right Format","permalink":"/hackathon-book/docs/module2/urdf-vs-sdf"}}');var r=s(4848),o=s(8453);const a={id:"gazebo-simulation",title:"Gazebo Simulation Fundamentals",sidebar_position:1,description:"Master Gazebo Classic and Gazebo Sim for realistic robot simulation with physics, sensors, and ROS 2 integration"},t="Gazebo Simulation Fundamentals",l={},c=[{value:"Gazebo Classic vs Gazebo Sim (Ignition)",id:"gazebo-classic-vs-gazebo-sim-ignition",level:2},{value:"Installing Gazebo Sim on Ubuntu 22.04",id:"installing-gazebo-sim-on-ubuntu-2204",level:2},{value:"Launching Your First Robot in Gazebo",id:"launching-your-first-robot-in-gazebo",level:2},{value:"Understanding SDF (Simulation Description Format)",id:"understanding-sdf-simulation-description-format",level:2},{value:"Configuring Physics Engines",id:"configuring-physics-engines",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"DART (Dynamic Animation and Robotics Toolkit)",id:"dart-dynamic-animation-and-robotics-toolkit",level:3},{value:"Bullet",id:"bullet",level:3},{value:"Adding Sensors: Camera Plugin",id:"adding-sensors-camera-plugin",level:2},{value:"Adding Sensors: LIDAR (Laser Range Finder)",id:"adding-sensors-lidar-laser-range-finder",level:2},{value:"Joint Control: Effort (Torque) Plugin",id:"joint-control-effort-torque-plugin",level:2},{value:"Tuning Physics for Stability",id:"tuning-physics-for-stability",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"gazebo-simulation-fundamentals",children:"Gazebo Simulation Fundamentals"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gazebo"})," is the industry-standard open-source robot simulator, powering research labs, universities, and companies worldwide. It provides photorealistic 3D environments with accurate physics simulation, enabling you to test algorithms before deploying to expensive hardware. Whether you're prototyping a wheeled robot or a 50-DOF humanoid, Gazebo accelerates development and reduces risk."]}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, you'll learn to spawn robots in Gazebo, configure physics engines (ODE, Bullet, DART), add sensors (cameras, LIDAR, IMU), and integrate with ROS 2 for closed-loop control."}),"\n",(0,r.jsx)(n.h2,{id:"gazebo-classic-vs-gazebo-sim-ignition",children:"Gazebo Classic vs Gazebo Sim (Ignition)"}),"\n",(0,r.jsx)(n.p,{children:"The Gazebo ecosystem has two active versions:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Gazebo Classic (11)"}),(0,r.jsx)(n.th,{children:"Gazebo Sim (Ignition/Harmonic)"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"ROS 2 Support"})}),(0,r.jsxs)(n.td,{children:["Via ",(0,r.jsx)(n.code,{children:"gazebo_ros_pkgs"})," bridge"]}),(0,r.jsx)(n.td,{children:"Native integration"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Physics Engines"})}),(0,r.jsx)(n.td,{children:"ODE, Bullet, DART, Simbody"}),(0,r.jsx)(n.td,{children:"DART (primary), Bullet, TPE"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Rendering"})}),(0,r.jsx)(n.td,{children:"OGRE 1.x"}),(0,r.jsx)(n.td,{children:"OGRE 2.x (PBR materials)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Plugin System"})}),(0,r.jsx)(n.td,{children:"C++ only"}),(0,r.jsx)(n.td,{children:"C++, Python (future)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.td,{children:"Single-threaded"}),(0,r.jsx)(n.td,{children:"Multi-threaded physics"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Status"})}),(0,r.jsx)(n.td,{children:"Maintenance mode"}),(0,r.jsx)(n.td,{children:"Active development"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": Use ",(0,r.jsx)(n.strong,{children:"Gazebo Sim (Harmonic)"})," for new ROS 2 projects. It's included in ROS 2 Humble/Iron and offers better performance. However, many tutorials still reference Gazebo Classic, so understanding both is valuable."]}),"\n",(0,r.jsx)(n.h2,{id:"installing-gazebo-sim-on-ubuntu-2204",children:"Installing Gazebo Sim on Ubuntu 22.04"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Install Gazebo Harmonic (latest stable as of 2024)\nsudo apt-get update\nsudo apt-get install gazebo-sim gz-tools\n\n# Install ROS 2 Humble integration\nsudo apt-get install ros-humble-ros-gz-sim ros-humble-ros-gz-bridge\n\n# Verify installation\ngz sim --version\n# Expected: Gazebo Sim, version 8.x.x\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Test Gazebo"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gz sim shapes.sdf\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should see a window with geometric shapes (sphere, box, cylinder) falling under gravity."}),"\n",(0,r.jsx)(n.h2,{id:"launching-your-first-robot-in-gazebo",children:"Launching Your First Robot in Gazebo"}),"\n",(0,r.jsx)(n.p,{children:"Let's spawn the humanoid arm from our previous URDF chapter:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 1"}),": Convert URDF to SDF (Gazebo's native format)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# SDF supports more features than URDF (multiple models, lights, sensors)\ngz sdf -p my_humanoid_arm.urdf > my_humanoid_arm.sdf\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 2"}),": Create a ROS 2 launch file"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# launch/gazebo_humanoid.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, DeclareLaunchArgument\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nimport os\n\ndef generate_launch_description():\n    # Path to robot description\n    pkg_share = FindPackageShare('my_robot_description').find('my_robot_description')\n    urdf_file = os.path.join(pkg_share, 'urdf', 'humanoid_arm.urdf')\n\n    # Read URDF file\n    with open(urdf_file, 'r') as f:\n        robot_description = f.read()\n\n    # Gazebo world file (empty world by default)\n    world_file = PathJoinSubstitution([\n        FindPackageShare('my_robot_description'),\n        'worlds',\n        'empty.world'\n    ])\n\n    return LaunchDescription([\n        # Launch Gazebo Sim\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('ros_gz_sim'),\n                    'launch',\n                    'gz_sim.launch.py'\n                ])\n            ]),\n            launch_arguments={\n                'gz_args': '-r empty.sdf'  # -r starts paused\n            }.items()\n        ),\n\n        # Spawn robot at origin\n        Node(\n            package='ros_gz_sim',\n            executable='create',\n            arguments=[\n                '-name', 'humanoid_arm',\n                '-topic', 'robot_description',\n                '-x', '0.0',\n                '-y', '0.0',\n                '-z', '1.0'  # Spawn 1m above ground\n            ],\n            output='screen'\n        ),\n\n        # Robot State Publisher (TF tree)\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            output='screen',\n            parameters=[{\n                'robot_description': robot_description,\n                'use_sim_time': True  # CRITICAL: Use Gazebo's clock\n            }]\n        ),\n\n        # ROS-Gazebo bridge for clock\n        Node(\n            package='ros_gz_bridge',\n            executable='parameter_bridge',\n            arguments=['/clock@rosgraph_msgs/msg/Clock[gz.msgs.Clock'],\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Launch"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 launch my_robot_description gazebo_humanoid.launch.py\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected result"}),": Gazebo window opens with your humanoid arm floating 1m above ground plane. It will fall due to gravity and land on the ground."]}),"\n",(0,r.jsx)(n.h2,{id:"understanding-sdf-simulation-description-format",children:"Understanding SDF (Simulation Description Format)"}),"\n",(0,r.jsx)(n.p,{children:"While URDF describes kinematics, SDF extends this for simulation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.9">\n  <world name="default">\n    \x3c!-- Physics configuration --\x3e\n    <physics name="ode_physics" type="ode">\n      <max_step_size>0.001</max_step_size>  \x3c!-- 1ms timestep --\x3e\n      <real_time_factor>1.0</real_time_factor>  \x3c!-- 1x speed --\x3e\n      <real_time_update_rate>1000</real_time_update_rate>  \x3c!-- 1000 Hz --\x3e\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/ground_plane</uri>\n    </include>\n\n    \x3c!-- Robot model --\x3e\n    <include>\n      <uri>model://my_humanoid_arm</uri>\n      <pose>0 0 1.0 0 0 0</pose>  \x3c!-- x y z roll pitch yaw --\x3e\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key SDF features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiple models"}),": Unlike URDF, SDF can contain entire worlds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugins"}),": C++ extensions for sensors, actuators, custom physics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fuel models"}),": Cloud repository of pre-built models (",(0,r.jsx)(n.code,{children:"fuel.gazebosim.org"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics parameters"}),": Timestep, solver iterations, contact properties"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"configuring-physics-engines",children:"Configuring Physics Engines"}),"\n",(0,r.jsx)(n.p,{children:"Gazebo supports multiple physics engines, each with trade-offs:"}),"\n",(0,r.jsx)(n.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<physics name="ode_physics" type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n\n  <ode>\n    <solver>\n      <type>quick</type>  \x3c!-- or \'world\' for more accuracy --\x3e\n      <iters>50</iters>  \x3c!-- Constraint solver iterations --\x3e\n      <sor>1.3</sor>  \x3c!-- Successive Over-Relaxation --\x3e\n    </solver>\n\n    <constraints>\n      <cfm>0.0</cfm>  \x3c!-- Constraint Force Mixing (softness) --\x3e\n      <erp>0.2</erp>  \x3c!-- Error Reduction Parameter --\x3e\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Fast, stable for wheeled robots and simple manipulators\n",(0,r.jsx)(n.strong,{children:"Cons"}),": Less accurate for stiff contacts (humanoid feet on ground)"]}),"\n",(0,r.jsx)(n.h3,{id:"dart-dynamic-animation-and-robotics-toolkit",children:"DART (Dynamic Animation and Robotics Toolkit)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<physics name=\"dart_physics\" type=\"dart\">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n\n  <dart>\n    <solver>\n      <solver_type>dantzig</solver_type>  \x3c!-- LCP solver --\x3e\n    </solver>\n\n    <collision_detector>bullet</collision_detector>  \x3c!-- or 'ode', 'fcl' --\x3e\n  </dart>\n</physics>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Best for legged robots, accurate contact forces\n",(0,r.jsx)(n.strong,{children:"Cons"}),": Slower than ODE for large scenes"]}),"\n",(0,r.jsx)(n.h3,{id:"bullet",children:"Bullet"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<physics name="bullet_physics" type="bullet">\n  <max_step_size>0.001</max_step_size>\n\n  <bullet>\n    <solver>\n      <type>sequential_impulse</type>\n      <iters>50</iters>\n    </solver>\n  </bullet>\n</physics>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Good collision detection, used in games/movies\n",(0,r.jsx)(n.strong,{children:"Cons"}),": Less mature in Gazebo than ODE/DART"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": Use ",(0,r.jsx)(n.strong,{children:"DART"})," for humanoid robots (better contact handling), ",(0,r.jsx)(n.strong,{children:"ODE"})," for mobile robots (faster)."]}),"\n",(0,r.jsx)(n.h2,{id:"adding-sensors-camera-plugin",children:"Adding Sensors: Camera Plugin"}),"\n",(0,r.jsx)(n.p,{children:"Equip your robot with a camera:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to robot\'s head link in SDF --\x3e\n<sensor name="camera" type="camera">\n  <pose>0.05 0 0 0 0 0</pose>  \x3c!-- 5cm in front of head --\x3e\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>100</far>\n    </clip>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>  \x3c!-- Realistic sensor noise --\x3e\n    </noise>\n  </camera>\n\n  <update_rate>30</update_rate>  \x3c!-- 30 FPS --\x3e\n  <always_on>true</always_on>\n  <visualize>true</visualize>  \x3c!-- Show camera frustum in Gazebo --\x3e\n\n  \x3c!-- Publish to ROS 2 topic --\x3e\n  <plugin filename="gz-sim-sensors-system" name="gz::sim::systems::Sensors">\n    <render_engine>ogre2</render_engine>\n  </plugin>\n</sensor>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bridge camera to ROS 2"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# In launch file, add parameter_bridge node\nNode(\n    package='ros_gz_bridge',\n    executable='parameter_bridge',\n    arguments=[\n        '/camera@sensor_msgs/msg/Image[gz.msgs.Image',\n        '/camera/camera_info@sensor_msgs/msg/CameraInfo[gz.msgs.CameraInfo'\n    ],\n    output='screen'\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"View camera feed"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run rqt_image_view rqt_image_view /camera\n"})}),"\n",(0,r.jsx)(n.h2,{id:"adding-sensors-lidar-laser-range-finder",children:"Adding Sensors: LIDAR (Laser Range Finder)"}),"\n",(0,r.jsx)(n.p,{children:"For navigation and SLAM:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<sensor name="lidar" type="gpu_lidar">\n  <pose>0 0 0.2 0 0 0</pose>  \x3c!-- 20cm above base --\x3e\n  <topic>lidar</topic>\n  <update_rate>10</update_rate>\n  <lidar>\n    <scan>\n      <horizontal>\n        <samples>640</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>  \x3c!-- -180\xb0 --\x3e\n        <max_angle>3.14159</max_angle>   \x3c!-- +180\xb0 --\x3e\n      </horizontal>\n      <vertical>\n        <samples>16</samples>  \x3c!-- 16 vertical beams --\x3e\n        <resolution>1</resolution>\n        <min_angle>-0.261799</min_angle>  \x3c!-- -15\xb0 --\x3e\n        <max_angle>0.261799</max_angle>   \x3c!-- +15\xb0 --\x3e\n      </vertical>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.01</stddev>\n    </noise>\n  </lidar>\n\n  <plugin filename="gz-sim-sensors-system" name="gz::sim::systems::Sensors">\n    <render_engine>ogre2</render_engine>\n  </plugin>\n</sensor>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bridge to ROS 2"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"Node(\n    package='ros_gz_bridge',\n    executable='parameter_bridge',\n    arguments=['/lidar@sensor_msgs/msg/LaserScan[gz.msgs.LaserScan'],\n    output='screen'\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Visualize in RViz2"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"rviz2\n# Add -> By topic -> /lidar -> LaserScan\n# Set Fixed Frame to 'base_link'\n"})}),"\n",(0,r.jsx)(n.h2,{id:"joint-control-effort-torque-plugin",children:"Joint Control: Effort (Torque) Plugin"}),"\n",(0,r.jsx)(n.p,{children:"Control your robot's joints with PID controllers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to each actuated joint in SDF --\x3e\n<joint name="shoulder_pitch" type="revolute">\n  <parent>torso</parent>\n  <child>upper_arm</child>\n  \x3c!-- ... joint definition ... --\x3e\n\n  <plugin filename="gz-sim-joint-position-controller-system"\n          name="gz::sim::systems::JointPositionController">\n    <joint_name>shoulder_pitch</joint_name>\n    <topic>/shoulder_pitch/cmd_pos</topic>\n    <p_gain>100.0</p_gain>\n    <i_gain>0.1</i_gain>\n    <d_gain>10.0</d_gain>\n    <i_max>1.0</i_max>\n    <i_min>-1.0</i_min>\n    <cmd_max>50.0</cmd_max>  \x3c!-- Max effort (Nm) --\x3e\n    <cmd_min>-50.0</cmd_min>\n  </plugin>\n</joint>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Command joint position from ROS 2"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\n\nclass JointCommander(Node):\n    def __init__(self):\n        super().__init__('joint_commander')\n\n        self.publisher = self.create_publisher(\n            Float64,\n            '/shoulder_pitch/cmd_pos',\n            10\n        )\n\n        self.timer = self.create_timer(1.0, self.send_command)\n        self.position = 0.0\n\n    def send_command(self):\n        msg = Float64()\n        self.position += 0.1  # Increment 0.1 rad each second\n\n        if self.position > 1.57:  # 90 degrees\n            self.position = -1.57\n\n        msg.data = self.position\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Commanded position: {self.position:.2f} rad')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = JointCommander()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tuning-physics-for-stability",children:"Tuning Physics for Stability"}),"\n",(0,r.jsx)(n.p,{children:"Unstable simulations (robots exploding, jittering) often result from:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Problem 1: Timestep too large"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Solution: Reduce timestep for stiff systems --\x3e\n<max_step_size>0.0001</max_step_size>  \x3c!-- 0.1ms instead of 1ms --\x3e\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Problem 2: Insufficient solver iterations"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<ode>\n  <solver>\n    <iters>100</iters>  \x3c!-- Increase from default 50 --\x3e\n  </solver>\n</ode>\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Problem 3: Heavy links on weak joints"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Solution: Increase joint damping --\x3e\n<joint name="shoulder_pitch" type="revolute">\n  <dynamics>\n    <damping>1.0</damping>  \x3c!-- Nm/(rad/s) --\x3e\n    <friction>0.1</friction>\n  </dynamics>\n</joint>\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Problem 4: Collision geometry too complex"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Solution: Use convex decomposition or primitive shapes --\x3e\n<collision name="collision">\n  <geometry>\n    <cylinder radius="0.05" length="0.3"/>  \x3c!-- Simpler than mesh --\x3e\n  </geometry>\n</collision>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.p,{children:"For real-time humanoid simulation (50+ DOF):"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"1. Reduce rendering quality"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gz sim --render-engine ogre2 --render-quality low\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2. Disable GUI for headless runs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gz sim -s  # Server-only mode (no GUI)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"3. Use multi-threading"})," (DART only):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<physics type="dart">\n  <dart>\n    <collision_detector>bullet</collision_detector>\n    <solver>\n      <solver_type>pgs</solver_type>  \x3c!-- Parallel Gauss-Seidel --\x3e\n    </solver>\n  </dart>\n</physics>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"4. Profile physics performance"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gz topic -e -t /stats\n# Monitor real_time_factor (should be \u2265 1.0 for real-time)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Challenge"}),": Create a humanoid reaching task in Gazebo:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Spawn your 7-DOF arm from the URDF chapter"}),"\n",(0,r.jsx)(n.li,{children:"Add a target sphere at position (0.5, 0.3, 1.0)"}),"\n",(0,r.jsx)(n.li,{children:"Write a Python node that publishes joint positions to reach the target"}),"\n",(0,r.jsx)(n.li,{children:"Add a camera sensor to the robot's end effector"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Success criteria"}),":"]}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Robot spawns without physics errors"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Camera feed visible in RViz2"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","End effector reaches within 5cm of target"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Simulation runs at \u2265 0.5x real-time"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Gazebo versions"}),": Classic (maintenance) vs Sim/Harmonic (active)\n\u2705 ",(0,r.jsx)(n.strong,{children:"SDF format"}),": World description with physics, lighting, models\n\u2705 ",(0,r.jsx)(n.strong,{children:"Physics engines"}),": DART (legged robots), ODE (mobile robots), Bullet (general)\n\u2705 ",(0,r.jsx)(n.strong,{children:"Sensor plugins"}),": Camera, LIDAR, IMU with realistic noise models\n\u2705 ",(0,r.jsx)(n.strong,{children:"ROS 2 bridge"}),": ",(0,r.jsx)(n.code,{children:"ros_gz_bridge"})," for topic/service integration\n\u2705 ",(0,r.jsx)(n.strong,{children:"Joint control"}),": PID controllers with effort/position/velocity commands\n\u2705 ",(0,r.jsx)(n.strong,{children:"Performance"}),": Reduce timestep, increase iterations, simplify collision"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next steps"}),": Compare Gazebo with NVIDIA Isaac Sim to understand when to use photorealistic ray-tracing (synthetic data generation) vs fast physics (reinforcement learning training)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Related chapters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/hackathon-book/docs/module1/urdf-for-humanoids",children:"URDF for Humanoids"})," - Robot modeling prerequisite"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/hackathon-book/docs/module2/urdf-vs-sdf",children:"URDF vs SDF"})," - Deep dive into format differences"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/hackathon-book/docs/module3/isaac-sim",children:"Isaac Sim"})," - GPU-accelerated alternative"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>t});var i=s(6540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);