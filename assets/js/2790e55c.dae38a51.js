"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[6479],{1401:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"review/testing-validation","title":"Testing & Validation for Robotics Systems","description":"Comprehensive guide to testing ROS 2 robotics systems: unit testing with pytest, integration testing, simulation-based testing in Gazebo, hardware-in-the-loop (HIL), and CI/CD pipelines for autonomous humanoid robots.","source":"@site/docs/review/testing.md","sourceDirName":"review","slug":"/review/testing-validation","permalink":"/hackathon-book/docs/review/testing-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/MuhammadAhmed-Professional/hackathon-book/tree/master/frontend/docs/review/testing.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"testing-validation","title":"Testing & Validation for Robotics Systems","sidebar_label":"Testing & Validation","sidebar_position":1,"description":"Comprehensive guide to testing ROS 2 robotics systems: unit testing with pytest, integration testing, simulation-based testing in Gazebo, hardware-in-the-loop (HIL), and CI/CD pipelines for autonomous humanoid robots.","keywords":["ros2 testing","pytest","integration testing","gazebo testing","hardware-in-loop","ci/cd robotics","launch_testing","pytest-cov"]}}');var i=t(4848),o=t(8453);const r={id:"testing-validation",title:"Testing & Validation for Robotics Systems",sidebar_label:"Testing & Validation",sidebar_position:1,description:"Comprehensive guide to testing ROS 2 robotics systems: unit testing with pytest, integration testing, simulation-based testing in Gazebo, hardware-in-the-loop (HIL), and CI/CD pipelines for autonomous humanoid robots.",keywords:["ros2 testing","pytest","integration testing","gazebo testing","hardware-in-loop","ci/cd robotics","launch_testing","pytest-cov"]},a="Testing & Validation for Robotics Systems",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"The Robotics Testing Pyramid",id:"the-robotics-testing-pyramid",level:2},{value:"Unit Testing ROS 2 Nodes",id:"unit-testing-ros-2-nodes",level:2},{value:"Testing Framework: pytest + unittest",id:"testing-framework-pytest--unittest",level:3},{value:"Example 1: Testing a Simple Publisher Node",id:"example-1-testing-a-simple-publisher-node",level:3},{value:"Example 2: Testing with Mocked Sensors",id:"example-2-testing-with-mocked-sensors",level:3},{value:"Integration Testing with launch_testing",id:"integration-testing-with-launch_testing",level:2},{value:"Example: Testing Multi-Node Navigation System",id:"example-testing-multi-node-navigation-system",level:3},{value:"Simulation-Based Testing with Gazebo",id:"simulation-based-testing-with-gazebo",level:2},{value:"Example: Gazebo Regression Test for Balance",id:"example-gazebo-regression-test-for-balance",level:3},{value:"Hardware-in-the-Loop (HIL) Testing",id:"hardware-in-the-loop-hil-testing",level:2},{value:"Example: HIL Test for Motor Controller",id:"example-hil-test-for-motor-controller",level:3},{value:"CI/CD for Robotics with GitHub Actions",id:"cicd-for-robotics-with-github-actions",level:2},{value:"Complete CI/CD Pipeline",id:"complete-cicd-pipeline",level:3},{value:"Docker-Based CI for Reproducibility",id:"docker-based-ci-for-reproducibility",level:3},{value:"Code Coverage with pytest-cov",id:"code-coverage-with-pytest-cov",level:2},{value:"Performance Regression Testing",id:"performance-regression-testing",level:2},{value:"Safety Validation Testing",id:"safety-validation-testing",level:2},{value:"Example: Collision Detection Test",id:"example-collision-detection-test",level:3},{value:"Summary: Best Practices for Robotics Testing",id:"summary-best-practices-for-robotics-testing",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"testing--validation-for-robotics-systems",children:"Testing & Validation for Robotics Systems"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Testing robotics software is fundamentally different from testing traditional software. A bug in a web application might crash a browser; a bug in a humanoid robot control system could cause physical damage or injury. This chapter teaches you industry-standard testing methodologies for ROS 2 robotics systems, from unit tests to full hardware-in-the-loop validation."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why Robotics Testing is Hard"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physical Constraints"}),": Robots interact with the real world\u2014gravity, friction, collisions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-Component Systems"}),": Dozens of nodes, sensors, actuators must work in concert"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-Deterministic Behavior"}),": Sensor noise, network latency, environment variability"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety-Critical"}),": Failures can damage hardware or harm humans"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Expensive Hardware"}),": Can't test every scenario on real robots"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Learning Objectives"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Write unit tests for ROS 2 nodes using pytest and unittest"}),"\n",(0,i.jsx)(n.li,{children:"Implement integration tests for multi-node systems"}),"\n",(0,i.jsx)(n.li,{children:"Use Gazebo for simulation-based regression testing"}),"\n",(0,i.jsx)(n.li,{children:"Deploy hardware-in-the-loop (HIL) testing strategies"}),"\n",(0,i.jsx)(n.li,{children:"Build CI/CD pipelines with GitHub Actions"}),"\n",(0,i.jsx)(n.li,{children:"Achieve >80% code coverage with pytest-cov"}),"\n",(0,i.jsx)(n.li,{children:"Apply safety validation techniques (collision testing, workspace limits)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-robotics-testing-pyramid",children:"The Robotics Testing Pyramid"}),"\n",(0,i.jsx)(n.p,{children:"Traditional software uses the testing pyramid (many unit tests, fewer integration tests, minimal E2E tests). Robotics adds a fourth layer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502  HIL Testing    \u2502  (Real hardware + real environment)\n         \u2502   (Hours/Days)  \u2502\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502  Sim Testing    \u2502  (Gazebo/Isaac Sim)\n         \u2502   (Minutes)     \u2502\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502 Integration     \u2502  (Multi-node, launch_testing)\n         \u2502   (Seconds)     \u2502\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502   Unit Tests    \u2502  (Individual nodes, mocks)\n         \u2502 (Milliseconds)  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Robotics-Specific Testing Strategy"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unit Tests (70%)"}),": Test individual nodes with mocked sensors/actuators"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integration Tests (20%)"}),": Test node communication and coordination"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation Tests (8%)"}),": Validate behavior in Gazebo with physics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HIL Tests (2%)"}),": Final validation on real hardware"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"unit-testing-ros-2-nodes",children:"Unit Testing ROS 2 Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Unit tests verify individual ROS 2 nodes in isolation using mocks for sensors, actuators, and communication."}),"\n",(0,i.jsx)(n.h3,{id:"testing-framework-pytest--unittest",children:"Testing Framework: pytest + unittest"}),"\n",(0,i.jsxs)(n.p,{children:["ROS 2 supports both Python ",(0,i.jsx)(n.code,{children:"unittest"})," (built-in) and ",(0,i.jsx)(n.code,{children:"pytest"})," (preferred for modern robotics). We'll use ",(0,i.jsx)(n.strong,{children:"pytest"})," for cleaner syntax and better fixtures."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Installation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pip3 install pytest pytest-cov pytest-mock\nsudo apt install ros-humble-launch-testing\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-1-testing-a-simple-publisher-node",children:"Example 1: Testing a Simple Publisher Node"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Node Under Test"})," (",(0,i.jsx)(n.code,{children:"joint_state_publisher.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\nclass JointStatePublisher(Node):\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n        self.publisher = self.create_publisher(JointState, '/joint_states', 10)\n        self.timer = self.create_timer(0.1, self.publish_joint_states)\n\n        self.joint_names = ['shoulder_pitch', 'elbow', 'wrist']\n        self.positions = [0.0, 0.0, 0.0]\n\n    def publish_joint_states(self):\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = self.joint_names\n        msg.position = self.positions\n        self.publisher.publish(msg)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Unit Test"})," (",(0,i.jsx)(n.code,{children:"test_joint_state_publisher.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport pytest\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom joint_state_publisher import JointStatePublisher\n\n@pytest.fixture\ndef joint_publisher():\n    """Fixture to create and destroy node for each test"""\n    rclpy.init()\n    node = JointStatePublisher()\n    yield node\n    node.destroy_node()\n    rclpy.shutdown()\n\ndef test_node_name(joint_publisher):\n    """Test node has correct name"""\n    assert joint_publisher.get_name() == \'joint_state_publisher\'\n\ndef test_publisher_created(joint_publisher):\n    """Test publisher is created on correct topic"""\n    publishers = joint_publisher.get_publishers_info_by_topic(\'/joint_states\')\n    assert len(publishers) == 1\n    assert publishers[0].topic_type == \'sensor_msgs/msg/JointState\'\n\ndef test_joint_names(joint_publisher):\n    """Test joint names are correctly initialized"""\n    assert len(joint_publisher.joint_names) == 3\n    assert \'shoulder_pitch\' in joint_publisher.joint_names\n    assert \'elbow\' in joint_publisher.joint_names\n\ndef test_message_publication():\n    """Test that messages are published with correct format"""\n    rclpy.init()\n    publisher_node = JointStatePublisher()\n\n    # Create subscriber to capture messages\n    received_messages = []\n\n    class TestSubscriber(Node):\n        def __init__(self):\n            super().__init__(\'test_subscriber\')\n            self.subscription = self.create_subscription(\n                JointState,\n                \'/joint_states\',\n                lambda msg: received_messages.append(msg),\n                10\n            )\n\n    subscriber_node = TestSubscriber()\n\n    # Spin until message received (with timeout)\n    import time\n    start_time = time.time()\n    while len(received_messages) == 0 and (time.time() - start_time) < 2.0:\n        rclpy.spin_once(publisher_node, timeout_sec=0.1)\n        rclpy.spin_once(subscriber_node, timeout_sec=0.1)\n\n    # Assertions\n    assert len(received_messages) > 0, "No messages received"\n    msg = received_messages[0]\n    assert len(msg.name) == 3\n    assert len(msg.position) == 3\n    assert msg.name == [\'shoulder_pitch\', \'elbow\', \'wrist\']\n\n    # Cleanup\n    publisher_node.destroy_node()\n    subscriber_node.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run Tests"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pytest test_joint_state_publisher.py -v\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-2-testing-with-mocked-sensors",children:"Example 2: Testing with Mocked Sensors"}),"\n",(0,i.jsxs)(n.p,{children:["For nodes that depend on sensors (cameras, LiDAR, IMU), use ",(0,i.jsx)(n.strong,{children:"mocks"})," to avoid hardware dependencies."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Node Under Test"})," (",(0,i.jsx)(n.code,{children:"obstacle_detector.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import Bool\n\nclass ObstacleDetector(Node):\n    def __init__(self):\n        super().__init__('obstacle_detector')\n        self.subscription = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10\n        )\n        self.publisher = self.create_publisher(Bool, '/obstacle_detected', 10)\n        self.min_safe_distance = 0.5  # meters\n\n    def scan_callback(self, msg):\n        # Check if any laser reading is below threshold\n        min_distance = min(msg.ranges)\n        obstacle_detected = min_distance < self.min_safe_distance\n\n        detection_msg = Bool()\n        detection_msg.data = obstacle_detected\n        self.publisher.publish(detection_msg)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Unit Test with Mocked LiDAR"})," (",(0,i.jsx)(n.code,{children:"test_obstacle_detector.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport pytest\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import Bool\nfrom obstacle_detector import ObstacleDetector\n\ndef create_mock_scan(min_range, max_range, num_readings=360):\n    """Helper to create mock LaserScan messages"""\n    msg = LaserScan()\n    msg.header.stamp = rclpy.clock.Clock().now().to_msg()\n    msg.angle_min = 0.0\n    msg.angle_max = 6.28  # 2*pi\n    msg.angle_increment = 6.28 / num_readings\n    msg.range_min = 0.1\n    msg.range_max = 10.0\n    msg.ranges = [max_range] * num_readings\n    msg.ranges[0] = min_range  # Put obstacle at 0 degrees\n    return msg\n\ndef test_obstacle_detected():\n    """Test obstacle is detected when LiDAR reads distance < threshold"""\n    rclpy.init()\n    detector = ObstacleDetector()\n\n    received_detections = []\n\n    class DetectionSubscriber(Node):\n        def __init__(self):\n            super().__init__(\'detection_subscriber\')\n            self.subscription = self.create_subscription(\n                Bool, \'/obstacle_detected\',\n                lambda msg: received_detections.append(msg.data),\n                10\n            )\n\n    subscriber = DetectionSubscriber()\n\n    # Create publisher to send mock LiDAR data\n    class MockLidarPublisher(Node):\n        def __init__(self):\n            super().__init__(\'mock_lidar\')\n            self.publisher = self.create_publisher(LaserScan, \'/scan\', 10)\n\n        def publish_scan(self, scan_msg):\n            self.publisher.publish(scan_msg)\n\n    mock_lidar = MockLidarPublisher()\n\n    # Test case 1: Obstacle at 0.3m (below 0.5m threshold)\n    close_scan = create_mock_scan(min_range=0.3, max_range=5.0)\n    mock_lidar.publish_scan(close_scan)\n\n    # Spin to process message\n    for _ in range(10):\n        rclpy.spin_once(detector, timeout_sec=0.1)\n        rclpy.spin_once(subscriber, timeout_sec=0.1)\n        rclpy.spin_once(mock_lidar, timeout_sec=0.1)\n\n    assert len(received_detections) > 0\n    assert received_detections[-1] is True, "Obstacle should be detected at 0.3m"\n\n    # Test case 2: No obstacle at 2.0m (above threshold)\n    received_detections.clear()\n    far_scan = create_mock_scan(min_range=2.0, max_range=5.0)\n    mock_lidar.publish_scan(far_scan)\n\n    for _ in range(10):\n        rclpy.spin_once(detector, timeout_sec=0.1)\n        rclpy.spin_once(subscriber, timeout_sec=0.1)\n        rclpy.spin_once(mock_lidar, timeout_sec=0.1)\n\n    assert len(received_detections) > 0\n    assert received_detections[-1] is False, "No obstacle at 2.0m"\n\n    # Cleanup\n    detector.destroy_node()\n    subscriber.destroy_node()\n    mock_lidar.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Testing Patterns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixtures"}),": Use ",(0,i.jsx)(n.code,{children:"@pytest.fixture"})," to setup/teardown nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mock Messages"}),": Create helper functions to generate sensor messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timeouts"}),": Use ",(0,i.jsx)(n.code,{children:"spin_once()"})," with timeouts to avoid hanging tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Assertions"}),": Test both expected and edge cases (no obstacle, close obstacle)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"integration-testing-with-launch_testing",children:"Integration Testing with launch_testing"}),"\n",(0,i.jsxs)(n.p,{children:["Integration tests validate that multiple ROS 2 nodes work correctly together. ROS 2 provides ",(0,i.jsx)(n.code,{children:"launch_testing"})," for this purpose."]}),"\n",(0,i.jsx)(n.h3,{id:"example-testing-multi-node-navigation-system",children:"Example: Testing Multi-Node Navigation System"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Launch File"})," (",(0,i.jsx)(n.code,{children:"test_navigation.launch.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch_testing.actions import ReadyToTest\nimport pytest\n\ndef generate_test_description():\n    \"\"\"Launch nodes required for navigation test\"\"\"\n\n    # Launch obstacle detector\n    obstacle_detector_node = Node(\n        package='my_robot_pkg',\n        executable='obstacle_detector',\n        name='obstacle_detector'\n    )\n\n    # Launch path planner\n    path_planner_node = Node(\n        package='my_robot_pkg',\n        executable='path_planner',\n        name='path_planner'\n    )\n\n    # Launch mock LiDAR\n    mock_lidar_node = Node(\n        package='my_robot_pkg',\n        executable='mock_lidar',\n        name='mock_lidar'\n    )\n\n    return (\n        LaunchDescription([\n            obstacle_detector_node,\n            path_planner_node,\n            mock_lidar_node,\n            ReadyToTest()\n        ]),\n        {\n            'obstacle_detector': obstacle_detector_node,\n            'path_planner': path_planner_node,\n            'mock_lidar': mock_lidar_node,\n        }\n    )\n\n@pytest.mark.launch_test\ndef test_obstacle_triggers_replanning():\n    \"\"\"Test that obstacle detection triggers path replanning\"\"\"\n    import rclpy\n    from rclpy.node import Node\n    from std_msgs.msg import Bool\n    from nav_msgs.msg import Path\n\n    rclpy.init()\n\n    received_paths = []\n\n    class PathSubscriber(Node):\n        def __init__(self):\n            super().__init__('path_subscriber')\n            self.subscription = self.create_subscription(\n                Path, '/planned_path',\n                lambda msg: received_paths.append(msg),\n                10\n            )\n\n    subscriber = PathSubscriber()\n\n    # Wait for initial path\n    import time\n    timeout = 5.0\n    start_time = time.time()\n    while len(received_paths) == 0 and (time.time() - start_time) < timeout:\n        rclpy.spin_once(subscriber, timeout_sec=0.1)\n\n    assert len(received_paths) > 0, \"No initial path received\"\n    initial_path_length = len(received_paths[0].poses)\n\n    # Simulate obstacle detection\n    obstacle_pub = Node('obstacle_simulator')\n    detection_publisher = obstacle_pub.create_publisher(Bool, '/obstacle_detected', 10)\n\n    obstacle_msg = Bool()\n    obstacle_msg.data = True\n    detection_publisher.publish(obstacle_msg)\n\n    # Wait for replanned path\n    received_paths.clear()\n    start_time = time.time()\n    while len(received_paths) == 0 and (time.time() - start_time) < timeout:\n        rclpy.spin_once(subscriber, timeout_sec=0.1)\n        rclpy.spin_once(obstacle_pub, timeout_sec=0.1)\n\n    assert len(received_paths) > 0, \"No replanned path received\"\n    replanned_path_length = len(received_paths[0].poses)\n\n    # Replanned path should be different (longer to avoid obstacle)\n    assert replanned_path_length != initial_path_length, \"Path unchanged after obstacle\"\n\n    subscriber.destroy_node()\n    obstacle_pub.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run Integration Tests"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"launch_test test_navigation.launch.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"simulation-based-testing-with-gazebo",children:"Simulation-Based Testing with Gazebo"}),"\n",(0,i.jsx)(n.p,{children:"Simulation testing validates robot behavior in realistic physics environments before deploying to hardware."}),"\n",(0,i.jsx)(n.h3,{id:"example-gazebo-regression-test-for-balance",children:"Example: Gazebo Regression Test for Balance"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Script"})," (",(0,i.jsx)(n.code,{children:"test_balance_gazebo.py"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nTest humanoid balance in Gazebo simulation\nValidates that robot maintains upright posture under disturbances\n"""\nimport pytest\nimport rclpy\nfrom rclpy.node import Node\nfrom gazebo_msgs.srv import SpawnEntity, ApplyBodyWrench\nfrom geometry_msgs.msg import Wrench, Vector3\nfrom sensor_msgs.msg import Imu\nimport subprocess\nimport time\nimport math\n\nclass GazeboBalanceTest(Node):\n    def __init__(self):\n        super().__init__(\'gazebo_balance_test\')\n\n        # Service clients\n        self.spawn_client = self.create_client(SpawnEntity, \'/spawn_entity\')\n        self.wrench_client = self.create_client(ApplyBodyWrench, \'/apply_body_wrench\')\n\n        # Subscribe to IMU\n        self.imu_data = []\n        self.imu_sub = self.create_subscription(\n            Imu, \'/imu/data\',\n            lambda msg: self.imu_data.append(msg),\n            10\n        )\n\n    def spawn_humanoid(self, urdf_path):\n        """Spawn humanoid robot in Gazebo"""\n        with open(urdf_path, \'r\') as urdf_file:\n            robot_description = urdf_file.read()\n\n        request = SpawnEntity.Request()\n        request.name = \'test_humanoid\'\n        request.xml = robot_description\n        request.initial_pose.position.z = 1.0  # Spawn 1m above ground\n\n        future = self.spawn_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)\n\n        return future.result().success\n\n    def apply_push(self, force_x=10.0, duration=0.5):\n        """Apply horizontal force to robot torso (simulate push)"""\n        request = ApplyBodyWrench.Request()\n        request.body_name = \'test_humanoid::torso\'\n        request.wrench.force = Vector3(x=force_x, y=0.0, z=0.0)\n        request.duration.sec = int(duration)\n        request.duration.nanosec = int((duration % 1) * 1e9)\n\n        future = self.wrench_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future, timeout_sec=2.0)\n\n        return future.result().success\n\n    def get_tilt_angle(self):\n        """Calculate robot tilt from IMU orientation (quaternion to euler)"""\n        if not self.imu_data:\n            return None\n\n        imu = self.imu_data[-1]\n        q = imu.orientation\n\n        # Convert quaternion to roll angle (tilt around x-axis)\n        roll = math.atan2(\n            2 * (q.w * q.x + q.y * q.z),\n            1 - 2 * (q.x * q.x + q.y * q.y)\n        )\n\n        return math.degrees(roll)\n\n@pytest.fixture\ndef gazebo_world():\n    """Start Gazebo simulation before tests"""\n    gazebo_process = subprocess.Popen([\n        \'gazebo\', \'--verbose\', \'-s\', \'libgazebo_ros_factory.so\'\n    ])\n\n    time.sleep(3)  # Wait for Gazebo to start\n    yield gazebo_process\n\n    gazebo_process.terminate()\n    gazebo_process.wait()\n\ndef test_humanoid_balance_after_push(gazebo_world):\n    """Test: Robot should recover balance after 10N push"""\n    rclpy.init()\n    test_node = GazeboBalanceTest()\n\n    # Spawn robot\n    urdf_path = \'/path/to/humanoid.urdf\'\n    assert test_node.spawn_humanoid(urdf_path), "Failed to spawn robot"\n\n    # Wait for robot to stabilize\n    time.sleep(2.0)\n    for _ in range(50):\n        rclpy.spin_once(test_node, timeout_sec=0.1)\n\n    # Record initial tilt\n    initial_tilt = test_node.get_tilt_angle()\n    assert initial_tilt is not None\n    assert abs(initial_tilt) < 5.0, f"Robot not upright initially: {initial_tilt}\xb0"\n\n    # Apply 10N push\n    assert test_node.apply_push(force_x=10.0, duration=0.5), "Failed to apply force"\n\n    # Wait for recovery\n    time.sleep(3.0)\n    for _ in range(100):\n        rclpy.spin_once(test_node, timeout_sec=0.1)\n\n    # Check final tilt\n    final_tilt = test_node.get_tilt_angle()\n    assert final_tilt is not None\n    assert abs(final_tilt) < 10.0, f"Robot fell over: {final_tilt}\xb0"\n\n    get_logger().info(f"Balance test passed: {initial_tilt}\xb0 \u2192 {final_tilt}\xb0")\n\n    test_node.destroy_node()\n    rclpy.shutdown()\n\ndef test_humanoid_falls_with_strong_push(gazebo_world):\n    """Test: Robot should fall with 100N push (negative test)"""\n    rclpy.init()\n    test_node = GazeboBalanceTest()\n\n    assert test_node.spawn_humanoid(\'/path/to/humanoid.urdf\')\n    time.sleep(2.0)\n\n    # Apply strong push\n    assert test_node.apply_push(force_x=100.0, duration=0.5)\n\n    time.sleep(3.0)\n    for _ in range(100):\n        rclpy.spin_once(test_node, timeout_sec=0.1)\n\n    final_tilt = test_node.get_tilt_angle()\n    assert abs(final_tilt) > 45.0, "Robot should have fallen with 100N push"\n\n    test_node.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run Gazebo Tests"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pytest test_balance_gazebo.py -v -s\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hardware-in-the-loop-hil-testing",children:"Hardware-in-the-Loop (HIL) Testing"}),"\n",(0,i.jsx)(n.p,{children:"HIL testing validates software on real hardware with controlled inputs. This is the final testing stage before deployment."}),"\n",(0,i.jsx)(n.h3,{id:"example-hil-test-for-motor-controller",children:"Example: HIL Test for Motor Controller"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Setup"}),": Real robot motors connected via CAN bus, simulated sensor inputs"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nHardware-in-the-Loop test for motor controller\nTests actual motor hardware with scripted sensor inputs\n"""\nimport pytest\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\nfrom sensor_msgs.msg import JointState\nimport can  # python-can library for CAN bus\n\nclass MotorHILTest(Node):\n    def __init__(self):\n        super().__init__(\'motor_hil_test\')\n\n        # Publisher for desired joint positions\n        self.cmd_pub = self.create_publisher(\n            Float64, \'/joint/shoulder/command\', 10\n        )\n\n        # Subscriber for actual joint positions\n        self.actual_positions = []\n        self.state_sub = self.create_subscription(\n            JointState, \'/joint_states\',\n            lambda msg: self.actual_positions.append(msg.position[0]),\n            10\n        )\n\n        # CAN bus interface for direct motor communication\n        self.can_bus = can.interface.Bus(channel=\'can0\', bustype=\'socketcan\')\n\n    def send_position_command(self, position_rad):\n        """Send position command to motor"""\n        msg = Float64()\n        msg.data = position_rad\n        self.cmd_pub.publish(msg)\n\n    def read_motor_current(self):\n        """Read actual motor current from CAN bus"""\n        # Example: Read CAN message (motor-specific protocol)\n        msg = self.can_bus.recv(timeout=1.0)\n        if msg and msg.arbitration_id == 0x201:  # Motor status message\n            current_amps = int.from_bytes(msg.data[0:2], \'little\') * 0.01\n            return current_amps\n        return None\n\n@pytest.fixture\ndef motor_hardware():\n    """Setup/teardown for motor hardware"""\n    # Enable motor drivers\n    import os\n    os.system(\'sudo ip link set can0 type can bitrate 1000000\')\n    os.system(\'sudo ip link set up can0\')\n\n    yield\n\n    # Disable motors after test\n    os.system(\'sudo ip link set down can0\')\n\ndef test_motor_position_accuracy(motor_hardware):\n    """Test: Motor reaches commanded position within 0.05 rad"""\n    rclpy.init()\n    test_node = MotorHILTest()\n\n    # Command shoulder to 45 degrees (0.785 rad)\n    target_position = 0.785\n    test_node.send_position_command(target_position)\n\n    # Wait for motor to reach position\n    import time\n    time.sleep(2.0)\n\n    for _ in range(50):\n        rclpy.spin_once(test_node, timeout_sec=0.1)\n\n    # Check actual position\n    assert len(test_node.actual_positions) > 0, "No position feedback"\n    actual_position = test_node.actual_positions[-1]\n\n    error = abs(actual_position - target_position)\n    assert error < 0.05, f"Position error too large: {error} rad"\n\n    test_node.destroy_node()\n    rclpy.shutdown()\n\ndef test_motor_current_limit(motor_hardware):\n    """Test: Motor current never exceeds 10A"""\n    rclpy.init()\n    test_node = MotorHILTest()\n\n    # Command rapid movements\n    positions = [0.0, 1.57, -1.57, 0.0]  # 0\xb0, 90\xb0, -90\xb0, 0\xb0\n    max_current = 0.0\n\n    for pos in positions:\n        test_node.send_position_command(pos)\n\n        import time\n        for _ in range(20):\n            current = test_node.read_motor_current()\n            if current:\n                max_current = max(max_current, current)\n            time.sleep(0.05)\n\n    assert max_current < 10.0, f"Motor current exceeded limit: {max_current}A"\n\n    test_node.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Safety Considerations for HIL Testing"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Always test in a ",(0,i.jsx)(n.strong,{children:"safety enclosure"})," (cage, barriers)"]}),"\n",(0,i.jsxs)(n.li,{children:["Implement ",(0,i.jsx)(n.strong,{children:"emergency stop"})," (physical button, software watchdog)"]}),"\n",(0,i.jsxs)(n.li,{children:["Start with ",(0,i.jsx)(n.strong,{children:"low speeds and forces"}),", gradually increase"]}),"\n",(0,i.jsxs)(n.li,{children:["Monitor ",(0,i.jsx)(n.strong,{children:"temperature, current, voltage"})," in real-time"]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.strong,{children:"soft limits"})," before mechanical stops"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cicd-for-robotics-with-github-actions",children:"CI/CD for Robotics with GitHub Actions"}),"\n",(0,i.jsx)(n.p,{children:"Continuous integration ensures every code commit is tested automatically. For robotics, this includes unit tests, integration tests, and simulation tests."}),"\n",(0,i.jsx)(n.h3,{id:"complete-cicd-pipeline",children:"Complete CI/CD Pipeline"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:".github/workflows/ros2_ci.yml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"name: ROS 2 Humble CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-22.04\n    container:\n      image: osrf/ros:humble-desktop-full\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Install dependencies\n        run: |\n          apt-get update\n          apt-get install -y python3-pip python3-pytest python3-pytest-cov\n          apt-get install -y ros-humble-gazebo-ros-pkgs\n          pip3 install pytest-mock\n\n      - name: Build ROS 2 workspace\n        shell: bash\n        run: |\n          source /opt/ros/humble/setup.bash\n          mkdir -p /ros2_ws/src\n          cp -r . /ros2_ws/src/my_robot_pkg\n          cd /ros2_ws\n          colcon build --symlink-install\n          source install/setup.bash\n\n      - name: Run unit tests\n        shell: bash\n        run: |\n          source /opt/ros/humble/setup.bash\n          source /ros2_ws/install/setup.bash\n          cd /ros2_ws/src/my_robot_pkg\n          pytest tests/ -v --cov=my_robot_pkg --cov-report=xml\n\n      - name: Run integration tests\n        shell: bash\n        run: |\n          source /opt/ros/humble/setup.bash\n          source /ros2_ws/install/setup.bash\n          cd /ros2_ws\n          colcon test --packages-select my_robot_pkg\n          colcon test-result --verbose\n\n      - name: Run Gazebo simulation tests\n        shell: bash\n        run: |\n          source /opt/ros/humble/setup.bash\n          source /ros2_ws/install/setup.bash\n          # Start Xvfb for headless Gazebo\n          export DISPLAY=:99\n          Xvfb :99 -screen 0 1024x768x24 &\n          sleep 3\n          pytest /ros2_ws/src/my_robot_pkg/tests/simulation/ -v\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./coverage.xml\n          flags: unittests\n          name: ros2-coverage\n\n      - name: Static analysis (ruff)\n        run: |\n          pip3 install ruff\n          ruff check /ros2_ws/src/my_robot_pkg\n\n      - name: Check ROS 2 coding standards\n        run: |\n          pip3 install ament_lint\n          source /opt/ros/humble/setup.bash\n          cd /ros2_ws\n          ament_cpplint src/my_robot_pkg\n          ament_flake8 src/my_robot_pkg\n"})}),"\n",(0,i.jsx)(n.h3,{id:"docker-based-ci-for-reproducibility",children:"Docker-Based CI for Reproducibility"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dockerfile"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'FROM osrf/ros:humble-desktop-full\n\n# Install testing tools\nRUN apt-get update && apt-get install -y \\\n    python3-pip \\\n    python3-pytest \\\n    python3-pytest-cov \\\n    ros-humble-gazebo-ros-pkgs \\\n    ros-humble-launch-testing \\\n    && rm -rf /var/lib/apt/lists/*\n\nRUN pip3 install pytest-mock ruff\n\n# Create workspace\nWORKDIR /ros2_ws/src\nCOPY . /ros2_ws/src/my_robot_pkg\n\n# Build workspace\nWORKDIR /ros2_ws\nRUN . /opt/ros/humble/setup.sh && colcon build --symlink-install\n\n# Set entrypoint\nCOPY docker-entrypoint.sh /\nRUN chmod +x /docker-entrypoint.sh\nENTRYPOINT ["/docker-entrypoint.sh"]\nCMD ["bash"]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"docker-entrypoint.sh"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\nset -e\n\n# Source ROS 2\nsource /opt/ros/humble/setup.bash\nsource /ros2_ws/install/setup.bash\n\nexec "$@"\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run Tests in Docker"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"docker build -t my-robot-tests .\ndocker run --rm my-robot-tests pytest /ros2_ws/src/my_robot_pkg/tests -v\n"})}),"\n",(0,i.jsx)(n.h2,{id:"code-coverage-with-pytest-cov",children:"Code Coverage with pytest-cov"}),"\n",(0,i.jsxs)(n.p,{children:["Code coverage measures what percentage of your code is executed during tests. Industry standard for robotics: ",(0,i.jsx)(n.strong,{children:">80% coverage"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run Coverage Analysis"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pytest tests/ --cov=my_robot_pkg --cov-report=html --cov-report=term\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example Coverage Report"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"---------- coverage: platform linux, python 3.10 -----------\nName                              Stmts   Miss  Cover\n-----------------------------------------------------\nmy_robot_pkg/__init__.py              2      0   100%\nmy_robot_pkg/joint_publisher.py      45      3    93%\nmy_robot_pkg/obstacle_detector.py    38      5    87%\nmy_robot_pkg/path_planner.py         92     18    80%\n-----------------------------------------------------\nTOTAL                               177     26    85%\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Coverage Configuration"})," (",(0,i.jsx)(n.code,{children:".coveragerc"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ini",children:"[run]\nomit =\n    */tests/*\n    */setup.py\n    */launch/*\n\n[report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise NotImplementedError\n    if __name__ == .__main__.:\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-regression-testing",children:"Performance Regression Testing"}),"\n",(0,i.jsx)(n.p,{children:"For real-time robotics, performance is critical. Test that code changes don't degrade latency or throughput."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example: Path Planning Latency Test"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport pytest\nimport time\nfrom path_planner import PathPlanner\n\ndef test_path_planning_latency():\n    """Test: Path planning completes within 100ms"""\n    planner = PathPlanner()\n\n    start = (0.0, 0.0)\n    goal = (10.0, 10.0)\n    obstacles = [(5.0, 5.0, 1.0)]  # (x, y, radius)\n\n    # Measure planning time\n    start_time = time.perf_counter()\n    path = planner.plan(start, goal, obstacles)\n    end_time = time.perf_counter()\n\n    latency_ms = (end_time - start_time) * 1000\n\n    assert path is not None, "Planning failed"\n    assert latency_ms < 100.0, f"Planning too slow: {latency_ms:.2f}ms"\n\n    print(f"\u2713 Path planning latency: {latency_ms:.2f}ms")\n\n@pytest.mark.benchmark\ndef test_vslam_throughput():\n    """Test: VSLAM processes at least 10 FPS"""\n    from vslam_node import VSLAMNode\n    import rclpy\n\n    rclpy.init()\n    vslam = VSLAMNode()\n\n    # Simulate 100 camera frames\n    num_frames = 100\n    start_time = time.perf_counter()\n\n    for i in range(num_frames):\n        # Create mock camera frame\n        frame = create_mock_frame(width=640, height=480)\n        vslam.process_frame(frame)\n\n    end_time = time.perf_counter()\n\n    fps = num_frames / (end_time - start_time)\n    assert fps >= 10.0, f"VSLAM too slow: {fps:.1f} FPS"\n\n    print(f"\u2713 VSLAM throughput: {fps:.1f} FPS")\n\n    vslam.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Track Performance Over Time"})," (GitHub Actions):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- name: Run performance benchmarks\n  run: |\n    pytest tests/benchmarks/ --benchmark-json=benchmark.json\n\n- name: Store benchmark result\n  uses: benchmark-action/github-action-benchmark@v1\n  with:\n    tool: 'pytest'\n    output-file-path: benchmark.json\n    github-token: ${{ secrets.GITHUB_TOKEN }}\n    auto-push: true\n"})}),"\n",(0,i.jsx)(n.h2,{id:"safety-validation-testing",children:"Safety Validation Testing"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, safety is paramount. Validate workspace limits, collision avoidance, and emergency stops."}),"\n",(0,i.jsx)(n.h3,{id:"example-collision-detection-test",children:"Example: Collision Detection Test"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nTest collision detection and avoidance\nValidates that robot stops before hitting obstacles\n"""\nimport pytest\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\n\ndef test_emergency_stop_on_collision():\n    """Test: Robot stops when obstacle detected within 0.3m"""\n    rclpy.init()\n\n    # Mock robot controller\n    class RobotController(Node):\n        def __init__(self):\n            super().__init__(\'robot_controller\')\n            self.cmd_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n            self.emergency_stop = False\n\n            self.scan_sub = self.create_subscription(\n                LaserScan, \'/scan\',\n                self.scan_callback, 10\n            )\n\n        def scan_callback(self, msg):\n            min_distance = min(msg.ranges)\n            if min_distance < 0.3:\n                self.emergency_stop = True\n                # Publish zero velocity\n                stop_cmd = Twist()\n                self.cmd_pub.publish(stop_cmd)\n\n        def move_forward(self):\n            if not self.emergency_stop:\n                cmd = Twist()\n                cmd.linear.x = 0.5  # 0.5 m/s\n                self.cmd_pub.publish(cmd)\n\n    controller = RobotController()\n\n    # Simulate obstacle at 0.2m\n    mock_scan = LaserScan()\n    mock_scan.ranges = [0.2] * 360\n\n    # Publish scan\n    scan_pub = Node(\'mock_lidar\')\n    scan_publisher = scan_pub.create_publisher(LaserScan, \'/scan\', 10)\n    scan_publisher.publish(mock_scan)\n\n    # Process\n    for _ in range(10):\n        rclpy.spin_once(controller, timeout_sec=0.1)\n        rclpy.spin_once(scan_pub, timeout_sec=0.1)\n\n    assert controller.emergency_stop is True, "Emergency stop not triggered"\n\n    controller.destroy_node()\n    scan_pub.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary-best-practices-for-robotics-testing",children:"Summary: Best Practices for Robotics Testing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"1. Test Pyramid"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"70% unit tests (fast, isolated)"}),"\n",(0,i.jsx)(n.li,{children:"20% integration tests (multi-node)"}),"\n",(0,i.jsx)(n.li,{children:"8% simulation tests (Gazebo)"}),"\n",(0,i.jsx)(n.li,{children:"2% HIL tests (real hardware)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2. Testing Tools"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"pytest"}),": Unit and integration tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"launch_testing"}),": Multi-node integration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gazebo"}),": Physics-based simulation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"pytest-cov"}),": Code coverage analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GitHub Actions"}),": CI/CD automation"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"3. What to Test"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Functional"}),": Does it do what it's supposed to?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Is it fast enough? (latency, throughput)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety"}),": Does it stop/avoid collisions?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robustness"}),": Does it handle sensor noise, edge cases?"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"4. CI/CD Pipeline"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Code Commit \u2192 Unit Tests \u2192 Integration Tests \u2192 Simulation Tests \u2192 HIL Tests \u2192 Deploy\n    \u2193             \u2193              \u2193                   \u2193                 \u2193          \u2193\n  <1 min        <5 min         <15 min            <1 hour          <1 day   Manual\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"5. Coverage Goals"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Critical safety code: ",(0,i.jsx)(n.strong,{children:"100% coverage"})]}),"\n",(0,i.jsxs)(n.li,{children:["Core algorithms (planning, control): ",(0,i.jsx)(n.strong,{children:">90% coverage"})]}),"\n",(0,i.jsxs)(n.li,{children:["Utilities, helpers: ",(0,i.jsx)(n.strong,{children:">80% coverage"})]}),"\n",(0,i.jsxs)(n.li,{children:["Overall project: ",(0,i.jsx)(n.strong,{children:">85% coverage"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Additional Resources"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/Testing/Testing-Main.html",children:"ROS 2 Testing Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.pytest.org/",children:"pytest Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/ros2/launch/tree/humble/launch_testing",children:"launch_testing Examples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://gazebosim.org/api/gazebo/6/test_fixture.html",children:"Gazebo Testing Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/ros-tooling/action-ros-ci",children:"GitHub Actions for ROS 2"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next Chapter"}),": ",(0,i.jsx)(n.a,{href:"/hackathon-book/docs/review/next-steps",children:"Course Review & Next Steps"})]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);