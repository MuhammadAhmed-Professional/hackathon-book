"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[324],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}},9668:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module1/python-integration","title":"Python Integration with ROS 2","description":"Master rclpy for building Python-based ROS 2 nodes with publishers, subscribers, and timers","source":"@site/docs/module1/python-integration.md","sourceDirName":"module1","slug":"/module1/python-integration","permalink":"/hackathon-book/docs/module1/python-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/MuhammadAhmed-Professional/hackathon-book/tree/master/frontend/docs/module1/python-integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"python-integration","title":"Python Integration with ROS 2","sidebar_position":4,"description":"Master rclpy for building Python-based ROS 2 nodes with publishers, subscribers, and timers"},"sidebar":"tutorialSidebar","previous":{"title":"Nodes & Communication","permalink":"/hackathon-book/docs/module1/nodes-topics-services"},"next":{"title":"Actions & Services","permalink":"/hackathon-book/docs/module1/actions-and-services"}}');var i=s(4848),t=s(8453);const a={id:"python-integration",title:"Python Integration with ROS 2",sidebar_position:4,description:"Master rclpy for building Python-based ROS 2 nodes with publishers, subscribers, and timers"},o="Python Integration with ROS 2",l={},c=[{value:"Why Python for ROS 2?",id:"why-python-for-ros-2",level:2},{value:"The rclpy Node Lifecycle",id:"the-rclpy-node-lifecycle",level:2},{value:"Building a Python Publisher",id:"building-a-python-publisher",level:2},{value:"Building a Python Subscriber",id:"building-a-python-subscriber",level:2},{value:"Timers and Periodic Tasks",id:"timers-and-periodic-tasks",level:2},{value:"Parameters and Reconfiguration",id:"parameters-and-reconfiguration",level:2},{value:"Integration with NumPy and AI Libraries",id:"integration-with-numpy-and-ai-libraries",level:2},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"python-integration-with-ros-2",children:"Python Integration with ROS 2"})}),"\n",(0,i.jsxs)(n.p,{children:["Python has become the lingua franca of robotics and AI development. Its readability, extensive ecosystem (NumPy, OpenCV, PyTorch), and rapid prototyping capabilities make it ideal for robotics research and development. ROS 2's ",(0,i.jsx)(n.strong,{children:"rclpy"})," library provides a Pythonic interface to the ROS 2 middleware, enabling you to build sophisticated robotic systems without sacrificing the performance benefits of DDS."]}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, you'll learn to harness rclpy's power for creating publishers, subscribers, timers, and complex node architectures that integrate seamlessly with the ROS 2 ecosystem."}),"\n",(0,i.jsx)(n.h2,{id:"why-python-for-ros-2",children:"Why Python for ROS 2?"}),"\n",(0,i.jsx)(n.p,{children:"While C++ offers maximum performance for time-critical control loops, Python excels in several robotics domains:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Perception pipelines"}),": OpenCV, scikit-image, and PIL integration for computer vision"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AI/ML inference"}),": PyTorch, TensorFlow, and ONNX Runtime for neural network deployment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rapid prototyping"}),": Test algorithms quickly before C++ optimization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data science"}),": Pandas, Matplotlib, and Jupyter for experiment analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High-level coordination"}),": State machines, mission planning, and behavior trees"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance consideration"}),": rclpy uses Python's C extension API for message serialization, minimizing overhead. For hard real-time control (e.g., 1 kHz motor control), use C++ nodes; for perception and planning (10-100 Hz), Python is perfectly adequate."]}),"\n",(0,i.jsx)(n.h2,{id:"the-rclpy-node-lifecycle",children:"The rclpy Node Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"Every ROS 2 Python node follows this initialization pattern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n    def __init__(self):\n        super().__init__('my_node_name')  # Node name for ROS 2 graph\n        self.get_logger().info('Node initialized')\n\n        # Create publishers, subscribers, timers here\n        self.setup_communication()\n\n    def setup_communication(self):\n        # Setup method for clarity\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)  # Initialize ROS 2 Python client library\n    node = MyNode()\n\n    try:\n        rclpy.spin(node)  # Process callbacks indefinitely\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key components"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rclpy.init()"}),": Must be called before creating nodes (initializes DDS middleware)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Node"})," inheritance: Provides logging, parameter server, and communication factory methods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rclpy.spin()"}),": Processes callbacks in an event loop (blocks until Ctrl+C)"]}),"\n",(0,i.jsxs)(n.li,{children:["Cleanup: Always destroy nodes and shutdown rclpy in ",(0,i.jsx)(n.code,{children:"finally"})," block"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"building-a-python-publisher",children:"Building a Python Publisher"}),"\n",(0,i.jsx)(n.p,{children:"Let's create a node that publishes IMU (Inertial Measurement Unit) data at 100 Hz:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import Vector3, Quaternion\nimport math\nimport time\n\nclass ImuPublisher(Node):\n    def __init__(self):\n        super().__init__('imu_publisher')\n\n        # Create publisher: topic name, message type, queue size\n        self.publisher = self.create_publisher(Imu, '/imu/data', 10)\n\n        # Timer: 0.01 seconds = 100 Hz\n        self.timer = self.create_timer(0.01, self.publish_imu_data)\n\n        self.sequence = 0\n        self.get_logger().info('IMU publisher started at 100 Hz')\n\n    def publish_imu_data(self):\n        msg = Imu()\n\n        # Header with timestamp and frame\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'imu_link'\n\n        # Simulated orientation (quaternion)\n        angle = self.sequence * 0.01  # Slow rotation for demo\n        msg.orientation = Quaternion(\n            x=0.0,\n            y=0.0,\n            z=math.sin(angle / 2),\n            w=math.cos(angle / 2)\n        )\n\n        # Simulated angular velocity (rad/s)\n        msg.angular_velocity = Vector3(x=0.1, y=0.0, z=0.05)\n\n        # Simulated linear acceleration (m/s\xb2)\n        msg.linear_acceleration = Vector3(x=0.0, y=0.0, z=9.81)\n\n        self.publisher.publish(msg)\n        self.sequence += 1\n\n        if self.sequence % 100 == 0:  # Log every second\n            self.get_logger().info(f'Published IMU message {self.sequence}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ImuPublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Publisher parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topic name"}),": ",(0,i.jsx)(n.code,{children:"/imu/data"})," follows ROS 2 naming convention (absolute path)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue size"}),": 10 messages buffered if subscriber can't keep up"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"QoS profile"}),": Default is RELIABLE (all messages delivered) for sensor data"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Timestamp best practices"}),": Always use ",(0,i.jsx)(n.code,{children:"self.get_clock().now()"})," instead of Python's ",(0,i.jsx)(n.code,{children:"time.time()"})," for ROS 2 time compatibility (supports simulation time in Gazebo)."]}),"\n",(0,i.jsx)(n.h2,{id:"building-a-python-subscriber",children:"Building a Python Subscriber"}),"\n",(0,i.jsx)(n.p,{children:"Now let's create a node that subscribes to camera images and processes them with OpenCV:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport cv2\nimport numpy as np\n\nclass ImageProcessor(Node):\n    def __init__(self):\n        super().__init__('image_processor')\n\n        # CvBridge converts between ROS Image messages and OpenCV images\n        self.bridge = CvBridge()\n\n        # Subscriber: topic, message type, callback function, queue size\n        self.subscription = self.create_subscription(\n            Image,\n            '/camera/image_raw',\n            self.image_callback,\n            10\n        )\n\n        # Publisher for processed images\n        self.publisher = self.create_publisher(Image, '/camera/image_processed', 10)\n\n        self.get_logger().info('Image processor node started')\n\n    def image_callback(self, msg):\n        try:\n            # Convert ROS Image message to OpenCV format (BGR8)\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n\n            # Apply edge detection (Canny algorithm)\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\n            edges = cv2.Canny(gray, threshold1=50, threshold2=150)\n\n            # Convert back to BGR for publishing\n            edges_bgr = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)\n\n            # Convert OpenCV image back to ROS Image message\n            processed_msg = self.bridge.cv2_to_imgmsg(edges_bgr, encoding='bgr8')\n            processed_msg.header = msg.header  # Preserve timestamp\n\n            self.publisher.publish(processed_msg)\n\n            self.get_logger().info(\n                f'Processed image {msg.header.stamp.sec}.{msg.header.stamp.nanosec}',\n                throttle_duration_sec=1.0  # Log max once per second\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Image processing failed: {str(e)}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ImageProcessor()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Callback best practices"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep callbacks fast (< 10 ms for 100 Hz topics)"}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"throttle_duration_sec"})," for logging to avoid spam"]}),"\n",(0,i.jsx)(n.li,{children:"Always use try-except for robustness (malformed messages shouldn't crash the node)"}),"\n",(0,i.jsx)(n.li,{children:"Preserve message headers when republishing (maintains timestamp chain)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timers-and-periodic-tasks",children:"Timers and Periodic Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Timers are essential for control loops and periodic state updates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float32\n\nclass BatteryMonitor(Node):\n    def __init__(self):\n        super().__init__('battery_monitor')\n\n        # Publisher for battery voltage\n        self.voltage_pub = self.create_publisher(Float32, '/battery/voltage', 10)\n\n        # Timer: check battery every 5 seconds\n        self.timer = self.create_timer(5.0, self.check_battery)\n\n        self.voltage = 12.6  # Initial voltage (full charge)\n        self.discharge_rate = 0.01  # Volts per check\n\n        self.get_logger().info('Battery monitor started')\n\n    def check_battery(self):\n        # Simulate battery discharge\n        self.voltage -= self.discharge_rate\n\n        # Publish current voltage\n        msg = Float32()\n        msg.data = self.voltage\n        self.voltage_pub.publish(msg)\n\n        # Log warnings at specific thresholds\n        if self.voltage < 11.1:\n            self.get_logger().error(f'CRITICAL: Battery at {self.voltage:.2f}V!')\n        elif self.voltage < 11.5:\n            self.get_logger().warn(f'LOW: Battery at {self.voltage:.2f}V')\n        else:\n            self.get_logger().info(f'Battery: {self.voltage:.2f}V')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = BatteryMonitor()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Timer precision"}),": ROS 2 timers use the system clock by default. For sub-millisecond precision, use a real-time kernel (PREEMPT_RT patch) and set thread priorities."]}),"\n",(0,i.jsx)(n.h2,{id:"parameters-and-reconfiguration",children:"Parameters and Reconfiguration"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 parameters enable runtime configuration without recompiling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom rcl_interfaces.msg import ParameterDescriptor\n\nclass ConfigurablePublisher(Node):\n    def __init__(self):\n        super().__init__('configurable_publisher')\n\n        # Declare parameters with default values and descriptions\n        self.declare_parameter(\n            'publish_rate',\n            10.0,  # Default: 10 Hz\n            ParameterDescriptor(description='Publishing frequency in Hz')\n        )\n\n        self.declare_parameter(\n            'topic_name',\n            '/data',\n            ParameterDescriptor(description='Topic to publish on')\n        )\n\n        # Read parameters\n        rate = self.get_parameter('publish_rate').value\n        topic = self.get_parameter('topic_name').value\n\n        self.get_logger().info(f'Publishing to {topic} at {rate} Hz')\n\n        # Use parameters in node setup\n        self.publisher = self.create_publisher(Float32, topic, 10)\n        self.timer = self.create_timer(1.0 / rate, self.timer_callback)\n\n    def timer_callback(self):\n        msg = Float32()\n        msg.data = 42.0\n        self.publisher.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ConfigurablePublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Set parameters at launch"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run my_package configurable_publisher --ros-args -p publish_rate:=50.0 -p topic_name:=/custom_topic\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Change parameters at runtime"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 param set /configurable_publisher publish_rate 100.0\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-numpy-and-ai-libraries",children:"Integration with NumPy and AI Libraries"}),"\n",(0,i.jsx)(n.p,{children:"Python's true power emerges when integrating scientific libraries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nimport numpy as np\n\nclass ObstacleDetector(Node):\n    def __init__(self):\n        super().__init__('obstacle_detector')\n\n        self.subscription = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10\n        )\n\n        self.min_distance = 0.5  # meters\n\n    def scan_callback(self, msg):\n        # Convert ranges to NumPy array\n        ranges = np.array(msg.ranges)\n\n        # Filter out invalid readings (inf, nan)\n        valid_ranges = ranges[(ranges > msg.range_min) & (ranges < msg.range_max)]\n\n        if valid_ranges.size == 0:\n            return\n\n        # Find closest obstacle\n        min_range = np.min(valid_ranges)\n        min_index = np.argmin(ranges)\n\n        # Calculate angle of closest obstacle\n        angle = msg.angle_min + min_index * msg.angle_increment\n        angle_deg = np.degrees(angle)\n\n        if min_range < self.min_distance:\n            self.get_logger().warn(\n                f'OBSTACLE: {min_range:.2f}m at {angle_deg:.1f}\xb0',\n                throttle_duration_sec=0.5\n            )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ObstacleDetector()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NumPy advantages"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Vectorized operations (10-100x faster than Python loops)"}),"\n",(0,i.jsx)(n.li,{children:"Statistical functions (mean, std, percentile) for sensor fusion"}),"\n",(0,i.jsx)(n.li,{children:"Linear algebra (transformations, inverse kinematics)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Create a ",(0,i.jsx)(n.code,{children:"VelocityController"})," node that:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Subscribes to ",(0,i.jsx)(n.code,{children:"/odom"})," (nav_msgs/Odometry) to get current robot velocity"]}),"\n",(0,i.jsxs)(n.li,{children:["Publishes ",(0,i.jsx)(n.code,{children:"/cmd_vel"})," (geometry_msgs/Twist) to command velocity"]}),"\n",(0,i.jsxs)(n.li,{children:["Uses a parameter ",(0,i.jsx)(n.code,{children:"target_speed"})," (default 0.5 m/s)"]}),"\n",(0,i.jsx)(n.li,{children:"Implements a simple proportional controller to reach target speed"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Starter template"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class VelocityController(Node):\n    def __init__(self):\n        super().__init__('velocity_controller')\n        # TODO: Declare parameter, create subscriber and publisher\n\n    def odom_callback(self, msg):\n        current_speed = msg.twist.twist.linear.x\n        # TODO: Calculate error, publish cmd_vel\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"rclpy lifecycle"}),": init \u2192 create node \u2192 spin \u2192 destroy \u2192 shutdown\n\u2705 ",(0,i.jsx)(n.strong,{children:"Publishers"}),": ",(0,i.jsx)(n.code,{children:"create_publisher(MessageType, topic, qos)"}),"\n\u2705 ",(0,i.jsx)(n.strong,{children:"Subscribers"}),": ",(0,i.jsx)(n.code,{children:"create_subscription(MessageType, topic, callback, qos)"}),"\n\u2705 ",(0,i.jsx)(n.strong,{children:"Timers"}),": ",(0,i.jsx)(n.code,{children:"create_timer(period_sec, callback)"})," for periodic tasks\n\u2705 ",(0,i.jsx)(n.strong,{children:"CvBridge"}),": Bridge between ROS Image and OpenCV (install ",(0,i.jsx)(n.code,{children:"ros-humble-cv-bridge"}),")\n\u2705 ",(0,i.jsx)(n.strong,{children:"NumPy integration"}),": Convert ROS messages to arrays for scientific computing\n\u2705 ",(0,i.jsx)(n.strong,{children:"Parameters"}),": ",(0,i.jsx)(n.code,{children:"declare_parameter()"})," for runtime configuration"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next steps"}),": Learn URDF (Unified Robot Description Format) to model your robot's kinematics and visualize it in RViz. Understanding robot descriptions is essential before diving into simulation with Gazebo and Isaac Sim."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related chapters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/hackathon-book/docs/module1/ros2-architecture",children:"ROS 2 Architecture"})," - Understand the DDS foundation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/hackathon-book/docs/module1/nodes-topics-services",children:"Nodes, Topics, and Services"})," - Communication patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/hackathon-book/docs/module1/urdf-for-humanoids",children:"URDF for Humanoids"})," - Next chapter: robot modeling"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);